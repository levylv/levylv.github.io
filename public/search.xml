<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RSA加密算法</title>
    <url>/2016/04/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天在了解公钥加密算法的时候看到了RSA加密算法，在理解其原理后觉得算法思想很是巧妙，感触颇深。</p>
<ul>
<li>不对称加密比对称加密算法好在能够在防止中间人攻击的情况下，减少系统的算法数。</li>
<li>不对称加密要想完全防止中间人攻击，需要防止中间人伪造公钥，因此有一个国际数字证书认证机构，叫做 CA，会对每个提供 SSL 加密访问（https）的网站的公钥作一个签名认证。用户的浏览器事先内置了 CA 的公钥，每次收到目标网站传来的公钥，就用 CA 的公钥检验一下目标网站的公钥是否可靠。如果验证不通过，浏览器会发出警告。尤其是银行这样的网站，要注意其数字证书是否可靠。</li>
</ul>
<a id="more"></a>
<p>详细算法原理，看<a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科</a>。<br>其算法核心思想还是利用大数质因数分解的困难性和复杂性，若是有人能发明一种快速质因数分解算法，那RSA加密就要无容身之地喽，但这个难度估计就是证明数学上那些有关质数的猜想了。。。</p>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
  </entry>
  <entry>
    <title>Cuda、Tensorflow、Pytorch版本匹配</title>
    <url>/2020/02/10/ML%E6%A1%86%E6%9E%B6/Cuda%E3%80%81Tensorflow%E3%80%81Pytorch%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Tensorflow和Cuda、Cudnn版本对应关系"><a href="#Tensorflow和Cuda、Cudnn版本对应关系" class="headerlink" title="Tensorflow和Cuda、Cudnn版本对应关系"></a>Tensorflow和Cuda、Cudnn版本对应关系</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh6yeb38cmj315y0u0h0c.jpg" alt="image-20200728202135462" style="zoom:50%;"></p>
<p>所以Cuda 10.0以上版本，就需要tensorflow 1.13.1以上</p>
<h4 id="Pytorch和Cuda版本对应关系"><a href="#Pytorch和Cuda版本对应关系" class="headerlink" title="Pytorch和Cuda版本对应关系"></a>Pytorch和Cuda版本对应关系</h4><p><a href="https://pytorch.org/get-started/previous-versions/" target="_blank" rel="noopener">https://pytorch.org/get-started/previous-versions/</a></p>
<p>一般就Cuda 10.0的话，pytorch得是1.0.0以上</p>
]]></content>
      <categories>
        <category>ML框架</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow2.0的几个变动</title>
    <url>/2019/11/18/ML%E6%A1%86%E6%9E%B6/Tf%202.0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%98%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-原来API的变动"><a href="#1-原来API的变动" class="headerlink" title="1. 原来API的变动"></a>1. 原来API的变动</h2><p>原先v1.0的诸多API都是发生了变动或者删除：</p>
<ul>
<li><p>删除了tf.variable_scope, tf.get_variable</p>
</li>
<li><p>tf.layer弃用，高层api统一用tf.keras</p>
</li>
<li><p>原先一些api也都不要用了，目前可以用tf.compat.v1.*来代替，但是只维护一年。</p>
</li>
</ul>
<h2 id="2-动态图机制"><a href="#2-动态图机制" class="headerlink" title="2. 动态图机制"></a>2. 动态图机制</h2><ul>
<li>Eager execution作为默认工作模式<ul>
<li>Eager Execution（动态图机制）是TensorFlow的一个命令式编程环境，它无需构建计算图，可以直接评估你的操作：直接返回具体值，而不是构建完计算图后再返回。</li>
<li>有了Eager Execution，我们不再需要事先定义计算图，然后再在session里评估它。它允许用python语句控制模型的结构。</li>
</ul>
</li>
<li>AutoGraph<ul>
<li>在 TensorFlow 1.x 版本中，要开发基于张量控制流的程序，必须使用 tf.conf、tf. while_loop 之类的专用函数。这增加了开发的复杂度。</li>
<li>在 TensorFlow 2.x 版本中，可以通过自动图（AutoGraph）功能，将普通的 Python 控制流语句转成基于张量的运算图，大大简化了开发工作。</li>
</ul>
</li>
</ul>
<p>总体来看，动态图的机制和pytorch极像。目前为了稳妥起见，打算先不升级到2.0，用tf.13就行，高层api统一切换到tf.keras</p>
]]></content>
      <categories>
        <category>ML框架</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow中有关Graph和Session的几个问题</title>
    <url>/2017/07/15/ML%E6%A1%86%E6%9E%B6/Tf%E4%B8%AD%E6%9C%89%E5%85%B3Graph%E5%92%8CSession%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>晚上在写一个简单的cnn时遇到了一个编译错误，代码检查了半天没找到问题。。最后鬼使神差地把全局变量初始化语句改了一下，竟然编译通过了。。研究了一下原因，应该是默认graph的问题。于是，再加上之前的默认session，我把tensorflow中默认graph和默认session几个注意点总结一下。</p>
<h1 id="默认Session问题"><a href="#默认Session问题" class="headerlink" title="默认Session问题"></a>默认Session问题</h1><ul>
<li>session创建后，如果没有指定graph，则该session会调用默认的graph。</li>
<li>调用默认graph的话，session创建语句可以在文件任意位置。因为即使session放在前文，后文里若是定义了新的graph节点，这些节点也会加到默认graph中，接下来调用该session时，调用的也是新的默认graph。</li>
<li>如果以<code>sess = tf.Session()</code>创建session，则该session不会作为下文的默认session，需要以<code>with</code>语句开头调用该session后，才作为下文的默认session。如果以<code>sess = tf.InteractiveSession()</code>创建session, 则该session即是下文的默认session。<strong>默认session的好处是可以直接使用<code>operation.run()</code>或<code>tensor.eval()</code>, 无需指定session来run</strong>。</li>
<li><code>with</code>语句有个好处是，该代码块结束后，session会自动<code>close</code>。</li>
</ul>
<h1 id="默认Graph问题"><a href="#默认Graph问题" class="headerlink" title="默认Graph问题"></a>默认Graph问题</h1><ul>
<li>如果不指定graph，创建的新节点都会加入到默认graph中。注意，该graph是一个<strong>全局默认graph</strong>,也就说如果你定义了一个函数，这个函数里增加了一些节点，那么，每次调用这个函数，都会在默认graph中增加新节点！因此，如果想要定义类来实现算法，那么以防这种情况，建议将所有的节点操作放在类的初始化<code>__init__</code>方法中，这样对于每个实例，初始化也只会执行一次而已。</li>
<li>有个要特别注意的节点操作<code>tf.global_variables_intializer()</code>。该项操作读取的是<strong>当前默认graph中</strong>的variable，如果在前文中定义就会出现问题！举个例子，我在前文中定义<code>init_var = tf.global_variables_intializer()</code>，然后中间加入新的variable, 最后再执行<code>init_var.run()</code>，这样就会出现编译错误信息<code>Attempting to use uninitialized value beta1_power</code>！也就是我今天遇到的编译问题！我们只能重新执行<code>tf.global_variables_intializer().run()</code>才行！</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实上面说了那么多问题，其实只要规范好代码就可以避免上述问题。所谓的规范就是，session创建和variable初始化这两个步骤，都在graph定义完成后再执行！</p>
]]></content>
      <categories>
        <category>ML框架</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发环境配置</title>
    <url>/2020/06/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Step-1-VS-code"><a href="#Step-1-VS-code" class="headerlink" title="Step 1 - VS code"></a>Step 1 - VS code</h2><ul>
<li>汉化插件: chinese simplied language</li>
<li>格式化代码：Prettier</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// 修改settings.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"diffEditor.ignoreTrimWhitespace"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"editor.suggestSelection"</span>: <span class="string">"first"</span>,</span><br><span class="line">  // "eslint.codeActionsOnSave": true,</span><br><span class="line">  "eslint.validate": [</span><br><span class="line">    "javascript",</span><br><span class="line">    "javascriptreact",</span><br><span class="line">    "typescript",</span><br><span class="line">    <span class="string">"typescriptreact"</span></span><br><span class="line">  ],</span><br><span class="line">  "javascript.implicitProjectConfig.experimentalDecorators": true,</span><br><span class="line">  "terminal.integrated.rendererType": "dom",</span><br><span class="line">  "vsintellicode.modify.editor.suggestSelection": "automaticallyOverrodeDefaultValue",</span><br><span class="line">  "window.zoomLevel": 1,</span><br><span class="line">  "workbench.colorTheme": "Visual Studio Dark",</span><br><span class="line">  "workbench.iconTheme": "material-icon-theme",</span><br><span class="line">  "[json]": &#123;</span><br><span class="line">    "editor.defaultFormatter": "vscode.json-language-features"</span><br><span class="line">  &#125;,</span><br><span class="line">  "[html]": &#123;</span><br><span class="line">    "editor.defaultFormatter": "HookyQR.beautify"</span><br><span class="line">  &#125;,</span><br><span class="line">  "[javascript]": &#123;</span><br><span class="line">    "editor.defaultFormatter": "HookyQR.beautify"</span><br><span class="line">  &#125;,</span><br><span class="line">  "javascript.updateImportsOnFileMove.enabled": "always",</span><br><span class="line">  "files.exclude": &#123;</span><br><span class="line">    "**/.classpath": true,</span><br><span class="line">    "**/.project": true,</span><br><span class="line">    "**/.settings": true,</span><br><span class="line">    "**/.factorypath": true</span><br><span class="line">  &#125;,</span><br><span class="line">  "files.associations": &#123;</span><br><span class="line">    "*.py": "python"</span><br><span class="line">  &#125;,</span><br><span class="line">  "[less]": &#123;</span><br><span class="line">    "editor.defaultFormatter": "esbenp.prettier-vscode"</span><br><span class="line">  &#125;,</span><br><span class="line">  "[typescriptreact]": &#123;</span><br><span class="line">    "editor.defaultFormatter": "esbenp.prettier-vscode"</span><br><span class="line">  &#125;,</span><br><span class="line">  "powermode.enabled": true,</span><br><span class="line">  "powermode.presets": "flames",</span><br><span class="line">  "[javascriptreact]": &#123;</span><br><span class="line">    "editor.defaultFormatter": "esbenp.prettier-vscode"</span><br><span class="line">  &#125;,</span><br><span class="line">  "[typescript]": &#123;</span><br><span class="line">    "editor.defaultFormatter": "esbenp.prettier-vscode"</span><br><span class="line">  &#125;,</span><br><span class="line">  "typescript.updateImportsOnFileMove.enabled": "always",</span><br><span class="line">  //   "editor.codeActionsOnSave": &#123;</span><br><span class="line">  //     "source.fixAll.eslint": true</span><br><span class="line">  //   &#125;,</span><br><span class="line">  "editor.formatOnSave": true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 配置文件, prettier.config.js or .prettierrc.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 一行最多 100 字符</span><br><span class="line">  printWidth: 100,</span><br><span class="line">  // 使用 4 个空格缩进</span><br><span class="line">  tabWidth: 2,</span><br><span class="line">  // 不使用缩进符，而使用空格</span><br><span class="line">  useTabs: false,</span><br><span class="line">  // 行尾需要有分号</span><br><span class="line">  semi: true,</span><br><span class="line">  // 使用单引号</span><br><span class="line">  singleQuote: true,</span><br><span class="line">  // 对象的 key 仅在必要时用引号</span><br><span class="line">  quoteProps: 'as-needed',</span><br><span class="line">  // jsx 不使用单引号，而使用双引号</span><br><span class="line">  jsxSingleQuote: false,</span><br><span class="line">  // 末尾不需要逗号</span><br><span class="line">  trailingComma: 'none',</span><br><span class="line">  // 大括号内的首尾需要空格</span><br><span class="line">  bracketSpacing: true,</span><br><span class="line">  // jsx 标签的反尖括号需要换行</span><br><span class="line">  jsxBracketSameLine: false,</span><br><span class="line">  // 箭头函数，只有一个参数的时候，也需要括号</span><br><span class="line">  arrowParens: 'always',</span><br><span class="line">  // parser: "babylon",</span><br><span class="line">  // 每个文件格式化的范围是文件的全部内容</span><br><span class="line">  rangeStart: 0,</span><br><span class="line">  rangeEnd: Infinity,</span><br><span class="line">  // 不需要写文件开头的 @prettier</span><br><span class="line">  requirePragma: false,</span><br><span class="line">  // 不需要自动在文件开头插入 @prettier</span><br><span class="line">  insertPragma: false,</span><br><span class="line">  // 根据显示样式决定 html 要不要折行</span><br><span class="line">  htmlWhitespaceSensitivity: 'css',</span><br><span class="line">  // 换行符使用 lf</span><br><span class="line">  endOfLine: 'lf'</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>代码检查: ESLint</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// 配置文件 .eslintrc.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"react-app"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 忽略文件 .eslintignore</span><br></pre></td></tr></table></figure>
</li>
<li><p>括号高亮: Bracket Pair Colorizer</p>
</li>
</ul>
<h2 id="Step-2-yarn"><a href="#Step-2-yarn" class="headerlink" title="Step 2 - yarn"></a>Step 2 - yarn</h2><p>Facebook开发的yarn, 类似JAVA的maven管理工具，比npm更好一点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装yarn </span><br><span class="line">npm i -g yarn</span><br><span class="line"># 安装项目所有依赖</span><br><span class="line">yarn</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow中的变量作用域和名称作用域</title>
    <url>/2017/07/18/ML%E6%A1%86%E6%9E%B6/Tf%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%90%8D%E7%A7%B0%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在定义复杂网络时，为了让变量和操作更加清晰，我们需要用作用域scope来为变量或者操作加前缀。在Tensorflow中，总共有以下几个定义域操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.name_scope()</span><br><span class="line">tf.op_scope()</span><br><span class="line">tf.variable_scope()</span><br><span class="line">tf.variable_op_scope()</span><br></pre></td></tr></table></figure>
<p>主要可以分为两类：变量作用域和名称作用域。其中<code>tf.name_scope</code>和<code>tf.op_scope</code>都属于名称作用域，这两者的唯一区别就是values的参数位置不同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.name_scope(name, default_name=<span class="literal">None</span>, values=<span class="literal">None</span>)</span><br><span class="line">tf.op_scope(values, name, default_name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><code>tf.variable_scope</code>和<code>tf.variable_op_scope</code>都属于变量作用域，两者区别跟上面是类似的。</p>
<p>那么，变量作用域和名称作用域又有什么区别呢？</p>
<p>对于名称作用域，顾名思义，就是一旦定义了该作用域，该代码块中的<strong>变量和操作</strong>，全部会加上该作用域前缀，若作用域名称相同，则名称后缀自动加一。但是，也有一个例外就是<code>tf.get_variable()</code>这个操作。</p>
<p><code>tf.get_variable()</code>有以下的性质：</p>
<ul>
<li><code>tf.get_variable(&#39;name&#39;, ...)</code> 中的name是无视名称作用域的，也就是说，即使该操作在某名称作用域中，name也不会加上相应前缀。</li>
<li>不同于<code>tf.Variable()</code>通过直接获取值来初始化，<code>tf.get_variable()</code>则是通过变量名以及定义初始化分布来进行初始化，若变量名已经存在，那么程序就会报错，相反，如果对于<code>tf.Variable()</code>，我们定义了相同的变量名，则程序会在变量名后缀上自动加一。</li>
</ul>
<p>从某种意义上说，变量作用域<code>tf.variable_scope</code>就是为了<code>tf.get_variable</code>而设计的。</p>
<ul>
<li><code>tf.get_variable(&#39;name&#39;, ...)</code>中的name会自动加上变量作用域的后缀。</li>
<li>变量作用域可以设定<code>reuse = True</code>，从而定义相同名字的变量为共享变量，若名字不同，则会报错。个人认为，定义变量作用域以及该操作都是为了实现共享变量的功能。</li>
<li>变量作用域还可以为<code>tf.get_variable(&#39;name&#39;, ...)</code>设置默认的初始化分布！</li>
<li>最重要的一点是，<strong>变量作用域<code>tf.variable_scope(&#39;name&#39;)</code>一旦开启，也就相当于间接开启了一个名称作用域<code>tf.name_scope(&#39;name&#39;)</code>！</strong></li>
</ul>
<p>总结来说，这些设计的目的大概这样的：</p>
<ul>
<li>为了区分变量和操作，定义了名称作用域。</li>
<li>名称作用域和普通的变量创建操作有重复名称自动后缀加一的特性，因此无法实现变量共享，于是定义了<code>tf.get_variable</code>操作。</li>
<li><code>tf.get_variable</code>操作也需要加前缀，于是定义了变量作用域。变量作用域相当于加强版的名称作用域！</li>
</ul>
<p>最后，给个测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>):</span><br><span class="line">    v = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">    x = <span class="number">1.0</span> + v</span><br><span class="line"><span class="keyword">assert</span> v.name == <span class="string">"foo/v:0"</span></span><br><span class="line"><span class="keyword">assert</span> x.op.name == <span class="string">"foo/add"</span></span><br><span class="line"><span class="keyword">assert</span> x.name == <span class="string">"foo/add:0"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>, reuse = <span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">"bar"</span>):</span><br><span class="line">        v = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">        x = <span class="number">1.0</span> + v</span><br><span class="line">        y = <span class="number">1.0</span> + x</span><br><span class="line"><span class="keyword">assert</span> v.name == <span class="string">"foo/v:0"</span>  <span class="comment"># 共享变量</span></span><br><span class="line"><span class="keyword">assert</span> x.op.name == <span class="string">"foo_1/bar/add"</span>  <span class="comment"># foo此时为名称作用域，重复定义，需要加一</span></span><br><span class="line"><span class="keyword">assert</span> x.name == <span class="string">"foo_1/bar/add:0"</span></span><br><span class="line"><span class="keyword">assert</span> y.op.name == <span class="string">"foo_1/bar/add_1"</span> <span class="comment"># add操作重复定义，自动加一</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有一个关于名称作用域和变量作用域嵌套的问题，若使用对象而非字符串开启作用域，则该作用域不嵌套</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'t1'</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'t2'</span>):</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(scope):</span><br><span class="line">            x = tf.Variable(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">assert</span> x.op.name == <span class="string">'t1/Variable'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'t1'</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'t2'</span>):</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'t3'</span>):</span><br><span class="line">            x = tf.Variable(<span class="number">1</span>, name = scope) <span class="comment"># 这样也不嵌套</span></span><br><span class="line"><span class="keyword">assert</span> x.op.name == <span class="string">'t1_1'</span></span><br></pre></td></tr></table></figure>
<p>关于<code>tf.variable_scope()</code>和<code>tf.get_variable()</code>的更多操作，可以看<a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/how_tos/variable_scope.html" target="_blank" rel="noopener">共享变量-极客学院Wiki</a></p>
]]></content>
      <categories>
        <category>ML框架</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习流程</title>
    <url>/2019/08/10/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> <strong>京华哥强推:</strong></p>
<ul>
<li><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">es6</a> ===&gt;java  </p>
</li>
<li><p><a href="https://www.runoob.com/react/react-tutorial.html" target="_blank" rel="noopener">react</a>===&gt;springboot  </p>
</li>
<li><p><a href="https://ant.design/components/menu-cn/" target="_blank" rel="noopener">antd</a>===&gt;UI框架 </p>
</li>
</ul>
<p><strong>Joe哥整理</strong></p>
<p><strong>第三方技术</strong><br>（1）React全家桶：React、Redux、Sagas、immutableJS<br>（2）框架：DVA、ANTD PRO<br>（3）组件库：ANTD<br>（4）打包：webpack4<br>（5）服务端渲染：puppeteer</p>
<p><strong>软件安装</strong><br>（1）NodeJS v10.15.0+<br>（2）Nginx 1.15.2+<br>（3）开发工具 VSCode</p>
<p><strong>优先学习</strong><br>Saga: 副作用Effects管理<br>redux: 状态机管理<br>dva = redux + saga<br><a href="https://www.html.cn/create-react-app/docs/getting-started/" target="_blank" rel="noopener">Create react app</a> : 脚手架，快速创建react app</p>
<p><strong>书籍推荐</strong></p>
<ul>
<li>初级：《HTML5权威指南》、《CSS权威指南》、《JAVASCRIPT权威指南》</li>
<li>中级：《JAVASCRIPT 高级程序设计》、《DOM编程艺术》、《CSS世界》、《ES6标准入门》、《NodeJS深入浅出》</li>
<li>高级：《你不知道的JAVASCRIPT上》、《你不知道的JAVASCRIPT中》、《你不知道的JAVASCRIPT下》、《CSS揭秘》、《Webkit技术内幕》</li>
</ul>
<p><strong>开源技术博客文档推荐</strong></p>
<ul>
<li>React：<a href="https://reactjs.org/docs/getting-started.html" target="_blank" rel="noopener">官方教程</a></li>
<li>Redux：<a href="https://www.redux.org.cn/" target="_blank" rel="noopener">官方教程</a></li>
<li>Redux-saga：<a href="https://redux-saga-in-chinese.js.org/" target="_blank" rel="noopener">官方文档</a></li>
<li>ImmutableJS：<a href="https://cn.redux.js.org/docs/recipes/UsingImmutableJS.html" target="_blank" rel="noopener">结合 Immutable.JS 使用 Redux</a>、<a href="https://immutable-js.github.io/immutable-js/docs/#/" target="_blank" rel="noopener">官方文档</a></li>
<li>ANTD组件库：<a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">官方文档</a>、<a href="https://ant.design/docs/react/recommendation-cn" target="_blank" rel="noopener">相关社区精华，不了解就太遗憾了</a></li>
</ul>
]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow和Pytorch的比较</title>
    <url>/2020/07/29/ML%E6%A1%86%E6%9E%B6/Tensorflow%E5%92%8CPytorch%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>来自：<a href="https://zhuanlan.zhihu.com/p/110177607" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110177607</a></p>
<p>Tensorflow 在工业界有着更广泛的应用，Pytorch在学术界有着更广泛的应用。</p>
<p>TensorFlow强在在线部署，多语言支持和较好的线上系统稳定性，我觉得这个是TensorFlow在业界被广泛应用的最主要原因。在业界，无论算法性能有多好，总归还是要上线的，不然都是白扯，不上线就算不到kpi中去。而方便部署到线上，支持多语言，并且有较好的系统稳定性以及有非常多线上应用实例是TensorFlow称霸业界的主要原因。</p>
<p>比较好一点的公司会在线上部署TensorFlow Serving，这样算法科学家们只需要提供相应的Tensorflow model即可将模型上线。但是据我所知，在国内某电商巨头公司内部，只有某院才能够使用TensorFlow Serving, 其他业务部门(包括很多小公司)想将TensorFlow modle上到线上，一律通过TensorFlow api来加载模型，做线上serve。这时候TensorFlow 支持多语言的特性就发挥了巨大的作用，它不仅支持c++， python，还支持如java等语言；很多公司目前的infrastructure 还没有针对AI做更新换代，也不提供相应的TensorFlow serving 能力，所以这些公司基本都用C++或者java来做TensorFlow 模型的线上serve。再者，TensorFlow基于静态图的这种方式非常适合线上应用，一次build好graph，多次在这个图上面做inference，工程效率很高。</p>
<p>但是在线下，TensorFlow体验很差，用过的人都觉得体验很不好。1. 在TensorFlow1.x时期，基于静态图的模式，无法在变量定义和使用的时候查看tensor的值，只有在session run的时候才能查看tensor的值，使得debug起来异常困难。2. TensorFlow API混乱，使用体验比较差。</p>
<p>而Pytorch 在API和文档方面都做得更好，并且pytorch是基于动态图的模式，可以很方便的查看tensor的值，可以像debug Python程序一样debug pytorch模型。因此，pytorch在只关心算法性能而不用太关心部署的学术界，非常受欢迎。</p>
<p>虽然TensorFlow2.x默认是eager execution模式，可以像pytorch一样直接查看tensor的值，但是个人感觉出来的还是有点晚，短时间内可能不太会是主流的线下框架了。一方面，已经习惯TensorFlow1.x的人还要重新学习tensorflow2.x，并且在TensorFlow1.x中静态图习惯的一些写法，在TensorFlow2.x可能不怎么支持，还要重新再踩很多坑，才能比较好的掌握；另一方面，习惯使用pytorch的那波人不太会去在学习TensorFlow2.x。</p>
<p>虽然Pytorch在新版本中也出了新的特性，更好的支持线上部署，但毕竟是才出来不久，没有经过线上的长时间检验，实际线上应用案例和分享也比较少。而TensorFlow自15年release以来，已经在线上经历了五年多的考验，撑过了多次双十一高流量的检测，性能稳定。Pytorch想更广泛应用在线上，短时间内也不太现实，替换成本还是很高，TensorFlow在这方面已经占尽了先机。</p>
<p>总的来说，Tensorflow在业界线上部署占尽了先机，而Pytorch在线下占尽了先机，短时间内谁都不能很快的取代谁。</p>
<h3 id="现在较好的部署手段"><a href="#现在较好的部署手段" class="headerlink" title="现在较好的部署手段"></a>现在较好的部署手段</h3><h5 id="使用Tensorflow"><a href="#使用Tensorflow" class="headerlink" title="使用Tensorflow"></a>使用Tensorflow</h5><ul>
<li>TF-serving</li>
<li>Tensorflow java/C++/python api，自定义服务上线</li>
<li>转成uff模型，tensorRT上线 </li>
</ul>
<h5 id="使用Pytorch"><a href="#使用Pytorch" class="headerlink" title="使用Pytorch"></a>使用Pytorch</h5><ul>
<li>Pytorch python等api，自定义服务上线</li>
<li>转成tensorflow模型，然后参考tensorflow上线方式</li>
<li>转成onnx模型，tensorRT上线</li>
</ul>
<p>TensorRT：<a href="https://zhuanlan.zhihu.com/p/88318324" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88318324</a></p>
]]></content>
      <categories>
        <category>ML框架</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow一些常用方法记录</title>
    <url>/2020/10/28/ML%E6%A1%86%E6%9E%B6/Tf%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="tf-stack"><a href="#tf-stack" class="headerlink" title="tf.stack"></a>tf.stack</h3><p>tf.stack(values, axis=0, name=”stack”):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.constant([<span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line">y = tf.constant([<span class="number">2</span>, <span class="number">5</span>])</span><br><span class="line">z = tf.constant([<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">tf.stack([x, y, z])  <span class="comment"># [[1, 4], [2, 5], [3, 6]] (Pack along first dim.)</span></span><br><span class="line">tf.stack([x, y, z], axis=<span class="number">1</span>)  <span class="comment"># [[1, 2, 3], [4, 5, 6]]</span></span><br></pre></td></tr></table></figure>
<p>本质是把一个长度为N的list，list里的元素有自己的shape：</p>
<ul>
<li>axis = 0，则变为（N，shape[0], shape[1], …）</li>
<li>axis = 1，则变为（shape[0], N, shape[1], …）</li>
</ul>
<p>常见用法有：</p>
<p>如果元素为长度为M的list</p>
<ul>
<li>Axis =0,  其实就相当于横着concate</li>
<li>Axis =1，相当于把元素看为列向量，然后竖着concate</li>
</ul>
<h3 id="tf-gather和tf-gather-nd"><a href="#tf-gather和tf-gather-nd" class="headerlink" title="tf.gather和tf.gather_nd"></a>tf.gather和tf.gather_nd</h3><p>tf.gather(params, indices, validate_indices=None, name=None, axis=0):</p>
<p>对于params,就是你的输入，axis就是你进行操作的维度，默认为0(对于tf.gather,只能对于给定的axis操作),indices就是你想获取的axis维度上的值，来看一个例子，可以更佳清楚的了解函数是如何使用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = tf.range(<span class="number">0</span>,<span class="number">10</span>)*<span class="number">10</span> + tf.constant(<span class="number">1</span>,shape=[<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">temp2 = tf.gather(temp,[<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> sess.run(temp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> sess.run(temp2)</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">[ <span class="number">1</span> <span class="number">11</span> <span class="number">21</span> <span class="number">31</span> <span class="number">41</span> <span class="number">51</span> <span class="number">61</span> <span class="number">71</span> <span class="number">81</span> <span class="number">91</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">11</span> <span class="number">51</span> <span class="number">91</span>]</span><br></pre></td></tr></table></figure>
<p>tf.gather只能对低维度进行操作，gather_nd可以进行高维度的操作。和gather相比，没有了axis参数，如果indices的维度和params的维度等价，他是直接获取一个具体值(之后组合成向量)。</p>
<h3 id="tf-expand-dims和tf-squeeze"><a href="#tf-expand-dims和tf-squeeze" class="headerlink" title="tf.expand_dims和tf.squeeze"></a>tf.expand_dims和tf.squeeze</h3><ul>
<li>tf.expand_dims(input, axis=None)，就是在对应的axis上加个1的维度，这样可以让tensorflow的元素乘和元素加运算可以用上broadcast机制。</li>
<li><p>broadcast机制：满足下面两个条件即可进行元素复制。</p>
<ul>
<li>从后往前维度相同</li>
<li>遇到不同的话，必须有一个维度为1.</li>
<li>举例：<ul>
<li>a.shape = (4,1,3,3), b.shape(1,3), a+b = (4,1,3,3)</li>
<li>a.shape = (4,1,1,3), b.shape(3,1), a+b = (4,1,3,3)</li>
</ul>
</li>
</ul>
</li>
<li><p>tf.squeeze则相反，去掉维度为1的维度。</p>
</li>
</ul>
<h3 id="tf-split"><a href="#tf-split" class="headerlink" title="tf.split()"></a>tf.split()</h3><p>将矩阵的某一维度切分为一个list。</p>
<ul>
<li>‘value’ is a tensor with shape [5, 30]</li>
<li>split0, split1, split2 = tf.split(value, [4, 15, 11], 1)</li>
<li>tf.shape(split0)  # [5, 4]</li>
<li>tf.shape(split1)  # [5, 15]</li>
<li>tf.shape(split2)  # [5, 11]</li>
</ul>
<h3 id="tf-add-n"><a href="#tf-add-n" class="headerlink" title="tf.add_n()"></a>tf.add_n()</h3><p>将input list里的tensor按元素相加，和普通相加没什么区别，只是可以加个operation name</p>
]]></content>
      <categories>
        <category>ML框架</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>伪多项式时间复杂度</title>
    <url>/2020/07/20/%E6%95%B0%E5%AD%A6/%E4%BC%AA%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>背包问题是典型的NPC问题，用动规求解的话，其复杂度为$O(mn)$，m为物品个数，n为背包大小。所以你可能奇怪，为什么这个复杂度看着明明是多项式时间，但为什么是NP问题？</p>
<p>这里就涉及到了伪多项式时间复杂度这个概念，请参考<a href="https://www.zhihu.com/question/20013122/answer/44460397" target="_blank" rel="noopener">知乎回答</a>。</p>
<p>一句话归纳：</p>
<blockquote>
<p>​    如果时间复杂度和输入数据的本身数值大小有关(传统公式里输入数据只代表规模，例如n个int整数)，那就是伪时间复杂度。</p>
</blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>《推荐系统实战》笔记</title>
    <url>/2020/07/22/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近看了项亮老师的《推荐系统实践》，做了相关的心得和笔记。</p>
<h3 id="一、推荐系统指标"><a href="#一、推荐系统指标" class="headerlink" title="一、推荐系统指标"></a>一、推荐系统指标</h3><ul>
<li>用户满意度：调查问卷等方式，也可以通过线上其他指标来衡量</li>
<li>预测准确度：<ul>
<li>评分预测：RMSE,MAE</li>
<li>TopN推荐：准确率和召回率</li>
</ul>
</li>
<li>覆盖率：物品流行度之间的差异，指标如熵、基尼系数</li>
<li>多样性：物品之间的相似性低，多样性高</li>
<li>新颖性：一般来讲，物品平均流行度低，新颖性高<ul>
<li>如何在不牺牲精度的情况下提高多样性和新颖性？</li>
</ul>
</li>
<li>惊喜度：与用户历史兴趣不同，但会让用户喜欢</li>
<li>信任度</li>
<li>实时性</li>
<li>健壮性</li>
<li>商业目标</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh03jbvuuzj31eo0ga76x.jpg" alt="image-20200722220000325" style="zoom:50%;"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh03j7ho93j31dr0du78g.jpg" alt="image-20200722220010615" style="zoom:45%;"></p>
<h3 id="二、基于用户行为分析的推荐算法"><a href="#二、基于用户行为分析的推荐算法" class="headerlink" title="二、基于用户行为分析的推荐算法"></a>二、基于用户行为分析的推荐算法</h3><p>仅仅基于用户行为数据设计的推荐算法一般称为协同过滤算法，学术界对协同过滤算法 进行了深入研究，提出了很多方法，比如基于邻域的方法(neighborhood-based)、隐语义模型(latent factor model)、基于图的随机游走算法(random walk on graph)等。最终目的都是生成用户和物品之间的兴趣度。</p>
<h4 id="基于领域的算法"><a href="#基于领域的算法" class="headerlink" title="基于领域的算法"></a>基于领域的算法</h4><p>统计方法：</p>
<ul>
<li>UserCF</li>
<li>ItemCF</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh0o54pwxuj31dt0oz13l.jpg" alt="image-20200723095329692" style="zoom:50%;"></p>
<h4 id="隐语义模型-Latent-Factor-Model"><a href="#隐语义模型-Latent-Factor-Model" class="headerlink" title="隐语义模型(Latent Factor Model)"></a>隐语义模型(Latent Factor Model)</h4><p>其实本质上就是训练得到用户的隐向量和物品的隐向量(Embedding的感觉)，然后再类似CTR预估。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh0o87nop6j30x40420tb.jpg" alt="image-20200723095628676" style="zoom:50%;"></p>
<ul>
<li>机器学习过程</li>
<li>离线空间复杂度较低，时间复杂度较高</li>
<li>实时性差，预测时候需要全量CTR预估再排序</li>
<li>解释性差</li>
</ul>
<h4 id="基于图模型"><a href="#基于图模型" class="headerlink" title="基于图模型"></a>基于图模型</h4><ul>
<li>生成用户与物品的图，计算顶点之间的相似度</li>
<li>PersonalRank，随机游走，类似马尔科夫过程，对于每个用户节点，生成所有节点访问概率，根据物品节点的概率生成推荐列表</li>
</ul>
<h3 id="三、冷启动问题"><a href="#三、冷启动问题" class="headerlink" title="三、冷启动问题"></a>三、冷启动问题</h3><p>主要分为三种问题：</p>
<ul>
<li>新用户冷启动</li>
<li>新物品冷启动</li>
<li>系统冷启动</li>
</ul>
<h4 id="针对新用户的冷启动"><a href="#针对新用户的冷启动" class="headerlink" title="针对新用户的冷启动"></a>针对新用户的冷启动</h4><ul>
<li><p>非个性化的热门推荐</p>
</li>
<li><p>利用用户的注册信息，例如年龄、性别等，做粗粒度的推荐。</p>
<ul>
<li>相当于只利用用户的注册信息等特征做CTR预估。</li>
</ul>
</li>
<li><p>要求用户注册填写感兴趣的领域。</p>
<ul>
<li>关键是如何选取有代表性、有区分度的领域。</li>
<li>算法：做一颗决策树，选取分裂节点时，选取方差最大的物品</li>
</ul>
</li>
<li><p>利用用户的社交网络，比如社交网络的好友推荐等，或者是外部网站的用户信息</p>
</li>
</ul>
<h4 id="针对新物品的冷启动"><a href="#针对新物品的冷启动" class="headerlink" title="针对新物品的冷启动"></a>针对新物品的冷启动</h4><ul>
<li>利用物品的自身内容，找计算物品相似度。<ul>
<li>可能会用到文本模型，例如LSI -&gt;PLSI -&gt; LDA(目前主要是这个)等，来生成物品向量，并计算相似度</li>
</ul>
</li>
<li>专家标注</li>
</ul>
<h3 id="四、利用用户标签数据的推荐算法"><a href="#四、利用用户标签数据的推荐算法" class="headerlink" title="四、利用用户标签数据的推荐算法"></a>四、利用用户标签数据的推荐算法</h3><p>标签相当于用户和物品之间的媒介(有点类似topic的感觉)，基于标签的推荐更加有解释性。</p>
<ul>
<li><p>基于标签的物品推荐算法：</p>
<ul>
<li><p>简单来讲，就是将标签作为一个隐向量来计算用户和物品的兴趣：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh0z5r4279j30dq039t8t.jpg" alt="image-20200723161433032" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<p>带上热门标签和热门物品的惩罚项：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh0z69qftej30o7053wez.jpg" alt="image-20200723161512422" style="zoom:50%;"></p>
<ul>
<li><p>标签拓展</p>
<ul>
<li>有些物品标签很少，这时候可以拓展标签，寻找相似标签。类似于itemCF的标签相似度计算方法</li>
</ul>
</li>
<li><p>标签清理</p>
<ul>
<li>如果我们要把标签呈现给用户，将其 作为给用户推荐某一个物品的解释，对标签的质量要求就很高。首先，这些标签不能包含没有意 义的停止词或者表示情绪的词。</li>
</ul>
</li>
<li><p>基于图的标签推荐算法</p>
<ul>
<li><p>利用标签作为中间层，类似于一个栅栏图。然后利用personalRank等计算节点相关性。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh0z8o963xj30py0jmag7.jpg" alt="image-20200723161730568" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>推荐打标签算法</p>
<ul>
<li>用户写标签的时候给他做推荐，很多算法：用户最常打标签，该物品最热门标签等</li>
</ul>
</li>
</ul>
<h3 id="五、利用上下文信息的推荐算法"><a href="#五、利用上下文信息的推荐算法" class="headerlink" title="五、利用上下文信息的推荐算法"></a>五、利用上下文信息的推荐算法</h3><p>上下文信息对用户兴趣的影响是很大的，主要代表是时间上下文和地点上下文。</p>
<h4 id="引入时间上下文"><a href="#引入时间上下文" class="headerlink" title="引入时间上下文"></a>引入时间上下文</h4><ul>
<li><p>可以通过统计发现，时间对对于物品流行度的影响。</p>
</li>
<li><p>推荐系统的时间多样性是很重要的(每天都有不同的推荐结果)，会影响用户满意度。</p>
</li>
<li><p>如何将时间上下文引入推荐系统？几个算法：</p>
<ul>
<li><p>TItemCF: 在计算物品相似度，预测用户和物品相似度时，引入时间衰减：</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh1119daluj30jd04w0t6.jpg" alt="image-20200723171933421" style="zoom:50%;"></p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh1b1eo7c6j30ly04edg4.jpg" alt="image-20200723171951909" style="zoom:50%;"></p>
</li>
<li><p>TUserCF: 也是同理：</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh112rl1ulj30f705uwev.jpg" alt="image-20200723172101864" style="zoom:50%;"></p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh112z8zs2j30hk044glu.jpg" alt="image-20200723172115518" style="zoom:50%;"></p>
</li>
<li><p>图模型：引入了时间段图模型，添加和时间有关的节点，然后再计算相关度，如果时间节点权重为0，就是普通的图。</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh114g1d01j30jn0hjwi3.jpg" alt="image-20200723172237557" style="zoom:50%;"></p>
</li>
<li><p>我自己检索了下如何在CTR预估模型里引入时间上下文。阿里有个Paper， DSTN，核心思想是在特征里引入上下文广告特征，这类似得引入了时空特征。</p>
</li>
</ul>
</li>
</ul>
<h4 id="引入地点上下文"><a href="#引入地点上下文" class="headerlink" title="引入地点上下文"></a>引入地点上下文</h4><p>介绍LARS算法，简单介绍一下：</p>
<ul>
<li><p>对于有用户位置的数据，基于兴趣的本地性，按照不同区域划分数据集，做不同层的推荐，然后按照权重，将推荐列表线性相加：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh117zdp49j30nk0fgta3.jpg" alt="image-20200723172604197" style="zoom:50%;"></p>
</li>
<li><p>对于有物品位置的数据，在最后的兴趣得分中添加惩罚项，当前物品与用户历史物品的平均位置的距离差。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh1b1dzur4j30n20210sz.jpg" alt="image-20200723172749452" style="zoom:50%;"></p>
</li>
</ul>
<h3 id="六、利用社交网络数据的推荐算法"><a href="#六、利用社交网络数据的推荐算法" class="headerlink" title="六、利用社交网络数据的推荐算法"></a>六、利用社交网络数据的推荐算法</h3><h4 id="基于社交网络的推荐"><a href="#基于社交网络的推荐" class="headerlink" title="基于社交网络的推荐"></a>基于社交网络的推荐</h4><ul>
<li>好友推荐增加推荐的新任务：基于社交网络的推荐不一定提升离线实验的指标，重在提升用户的信任度和可解释性。</li>
<li>可以解决新用户的冷启动问题，如前文所说</li>
</ul>
<p>相关算法：</p>
<ul>
<li><p>基于领域的社会化推荐算法</p>
<ul>
<li>其实就是类似于UserCF，只是计算用户相似度的时候，不仅考虑用户兴趣相似度(通过用户历史行为)，还通过社交网络考虑用户好友相似度：</li>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh1b1fknqlj309602vmx6.jpg" alt="image-20200723183158908" style="zoom:50%;"></li>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh134ues59j30gy0460t4.jpg" alt="image-20200723183214171" style="zoom:50%;"></li>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh134yzzlcj30ge03mwet.jpg" alt="image-20200723183223785" style="zoom:50%;"></li>
</ul>
</li>
<li><p>基于图的社会化推荐算法</p>
<ul>
<li>就是通过社交网络增加用户与用户的边，同样可以再用personalRank。</li>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh1361tvxfj30eg0g4mzj.jpg" alt="image-20200723183323298" style="zoom:50%;"></li>
</ul>
</li>
</ul>
<h4 id="实际系统中的社会化推荐算法"><a href="#实际系统中的社会化推荐算法" class="headerlink" title="实际系统中的社会化推荐算法"></a>实际系统中的社会化推荐算法</h4><p>因为用户数太多，如果给用户推荐的时候，去计算所有用户的话，代价太大，两种方法：</p>
<ul>
<li>只取相似度高的N个用户</li>
<li>设计一种特殊的数据存储结构：每个用户维护一个消息队列，其他相关用户产生一个物品行为，则在消息队列中添加该物品。这样的话，推荐计算的时候，只需读取自身的消息队列，然后通过队列里物品的相关信息来算即可。</li>
</ul>
<h4 id="社交网络好友推荐"><a href="#社交网络好友推荐" class="headerlink" title="社交网络好友推荐"></a>社交网络好友推荐</h4><p>其实就是计算用户与用户之间的相似度，还是可以通过兴趣相似度和好友相似度来做。</p>
<h3 id="七、推荐系统实例"><a href="#七、推荐系统实例" class="headerlink" title="七、推荐系统实例"></a>七、推荐系统实例</h3><p>一个真实的推荐网站有三部分组成：</p>
<ul>
<li><p>推荐系统</p>
</li>
<li><p>前端页面：需要展示推荐物品的相关信息，推荐理由，用户反馈设计</p>
</li>
<li><p>日志系统：不同的用户行为，有不同的规模大小和实时性需求，可能需要不同的数据存储结构</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh1706abmtj312i0dkjtt.jpg" alt="image-20200723204606329" style="zoom:50%;"></p>
</li>
</ul>
<p>一个推荐系统的组成：</p>
<ul>
<li>由不同的推荐引擎构成，来处理不同的推荐任务，比如个性化推荐、新颖性推荐、最新物品推荐等等</li>
<li>由推荐系统再过滤、排名、解释等汇总组合各个推荐引擎结果。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh1728ehxcj31ec0gxae3.jpg" alt="image-20200723204806073" style="zoom:50%;"></p>
<p>一个推荐引擎的架构，主要三部分：</p>
<ul>
<li>用户特征提取模块</li>
<li>特征-物品推荐模块：也俗称召回模块，就是本书介绍的算法模型。</li>
<li>对初始的推荐列表进行过滤、排名等处理，从而生成最终的推荐结果。排名模块里涉及到了CTR预估模型，也俗称精排模块。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh1746mn2fj31560sogrz.jpg" alt="image-20200723204959419" style="zoom:50%;"></p>
<p>重点聊下排名模块：</p>
<ul>
<li>这个终于让我知道了CTR预估模型在推荐系统里的作用！<strong>之前一直以为CTR预估模型也是类似CF等算法，但其实不是，CTR预估模型是针对推荐结果的精排</strong>，想想也是，只有推荐结果的点击才有真实的正负样本可以来训练！前面的召回模型哪来的负样本呢..用户没购买，并不意味这不喜欢物品啊。<strong>同时CTR预估模型也是计算广告系统非常重要的模型！CTR值直接影响了预算收益等。</strong></li>
<li>排名模块包含很多：<ul>
<li>新颖性排名：通过基于物品流行度来降低热门物品的权重</li>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh17af7pglj30fm03xmxc.jpg" alt="image-20200723205559196" style="zoom:50%;"></li>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh1b1f5awnj30vs03gaaj.jpg" alt="image-20200723205611181" style="zoom:50%;"></li>
<li>多样性排名：1. 对物品按内容分类，不同类目分别取物品 2. 对相同推荐理由的物品进行降权采样</li>
<li>时间多样性：对于之前推荐过的物品进行降权采样</li>
<li>用户反馈：排名模块最重要的部分。通过用户反馈拿到正负样本，用CTR预估模型，特征有：</li>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh17dapx4hj31bz0agafm.jpg" alt="image-20200723205845435" style="zoom:50%;"></li>
</ul>
</li>
</ul>
<h3 id="八、评分预测问题"><a href="#八、评分预测问题" class="headerlink" title="八、评分预测问题"></a>八、评分预测问题</h3><p>评分预测算法介绍：离线评测指标RMSE/MAE</p>
<ul>
<li>平均值相关</li>
<li>基于领域的方法，就类似UserCF，只是把r=1换成得分：<ul>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh18ruzpaqj30hm04smxk.jpg" alt="image-20200723214719938" style="zoom:50%;"></li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh18s7twz3j30ji04pq3d.jpg" alt="image-20200723214741412" style="zoom:50%;"></p>
<ul>
<li>隐语义模型与矩阵分解模型：<ul>
<li>SVD分解，取top k，再进行SVD计算，得到评分矩阵。缺点：SVD用户和物品的维度太大高，计算量太大</li>
<li>LFM，通过梯度下降求解SVD的隐向量，换发新春。</li>
</ul>
</li>
<li>加入时间信息<ul>
<li>基于邻域的模型融合时间信息：同之前TItemCF，TUserCF</li>
<li>基于矩阵分解的模型融合时间信息: 加入时间项</li>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh1atyz1gyj30vf02ewet.jpg" alt="image-20200723225835221" style="zoom:50%;"></li>
</ul>
</li>
<li>模型融合：<ul>
<li>模型级联融合：同adaboost</li>
<li>模型加权融合：同stacking</li>
</ul>
</li>
</ul>
<h3 id="结语：推荐系统十堂课"><a href="#结语：推荐系统十堂课" class="headerlink" title="结语：推荐系统十堂课"></a>结语：推荐系统十堂课</h3><ol>
<li>确定你真的需要推荐系统</li>
<li>确定商业目标和用户满意度之间的关系</li>
<li>选择合适的开发人员</li>
<li>忘记冷启动的问题</li>
<li>平衡数据和算法之间的关系</li>
<li>找到相关的物品很容易</li>
<li>不要浪费时间计算相似兴趣的用户，可以直接利用社会网络数据</li>
<li>需要不断地提升算法的扩展性</li>
<li>选择合适的用户反馈方式</li>
<li>设计合理的评测系统，时刻关注推荐系统各方面的性能</li>
</ol>
]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
      <tags>
        <tag>《推荐系统实战》</tag>
      </tags>
  </entry>
  <entry>
    <title>关于凸、P和NP</title>
    <url>/2019/08/27/%E6%95%B0%E5%AD%A6/%E5%85%B3%E4%BA%8E%E5%87%B8%E3%80%81P%E5%92%8CNP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>优化问题本质上分为凸和非凸两大类。</p>
</blockquote>
<p>凸问题有着巨大的优势：</p>
<ul>
<li><p>成熟有效的求解算法求得全局最优解。(内点法、椭圆法、梯度下降法等)</p>
</li>
<li><p>计算复杂度基本上是多项式的，基本是P的。</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhhkonh5dj30ui02jmy3.jpg" alt="image-20200605162015414"> </p>
<p>非凸问题则求解比较困难，实际上大部分的解法都是将非凸问题转化为凸问题。</p>
<blockquote>
<p>P，NP，NP-hard， NPC则是计算复杂度的表示。</p>
</blockquote>
<ul>
<li>P代表多项式内可求解的问题</li>
<li>NP代表多项式内可验证的问题</li>
<li>NP-hard表示所有NP问题都可以归约到该问题的问题</li>
<li>NPC表示即是NP-hard，本身又是NP问题的问题</li>
</ul>
<p>如果证明P=NP，其实意味着世界上所有的密码系统都被破解了。</p>
<p>因为加密是P的，解密验证是NP的，如果P=NP，说明解密也可以是P的，也就是任何解密算法都可以是多项式内求解的，那么解密就没有时间成本了，随意破解了。</p>
<blockquote>
<p>组合优化、混合整数规划等问题一般都是NP-hard问题，例如TSP，背包问题、汉密尔顿回路问题等等。</p>
</blockquote>
<p>因为P应该不等NP，这种问题也就是说很难找到多项式时间内的求解算法得到最优解。现在对这些算法的最优求解一般都是指数或者阶乘复杂度的，可参考acm题，算法的话有分支定界之类的。</p>
<p>但如果想要求解近似解，就可以是多项式时间的算法，例如先松弛成凸问题啊之类的。</p>
<blockquote>
<p>以前一直以为非凸问题就是没有多项式时间的算法求最优解，其实我理解错了，非凸问题很多都是可以转成凸问题的，例如log-log convex等问题。</p>
<p>典型的一些凸函数：</p>
</blockquote>
<ul>
<li>仿射函数</li>
<li>绝对值</li>
<li>最大值</li>
<li>p！= 0的所有范数</li>
<li>指数函数</li>
<li>a&gt; 1或者 &lt;0的幂函数</li>
<li>xlogx</li>
<li>以及一系列的保凸运算。。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhhmvitpaj30gp07i3zh.jpg" alt="image-20200605162217125"> </p>
<blockquote>
<p>典型的凸问题(等式约束一定要是仿射的！)：</p>
</blockquote>
<ul>
<li>线性规划 （LP）</li>
<li>二次规划  (QP)</li>
<li>半正定规划(不等式约束为LMI，线性矩阵不等式)(SDP)</li>
<li>锥规划(CP)</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhhoq7muvj30z50j840g.jpg" alt="image-20200605162259121" style="zoom: 50%;"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhhoovacoj30ku0dz0u6.jpg" alt="image-20200605162313667" style="zoom:67%;"></p>
<blockquote>
<p>对称的正定矩阵一定代表了是个凸锥。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhhopmtpvj30jr0djgmu.jpg" alt="image-20200605162344236"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>内积、叉积和外积</title>
    <url>/2021/01/08/%E6%95%B0%E5%AD%A6/%E5%86%85%E7%A7%AF%E3%80%81%E5%8F%89%E7%A7%AF%E5%92%8C%E5%A4%96%E7%A7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h3><p>首先介绍点积(dot product)，点积是一种接受两个等长的数字序列（通常是坐标向量）、返回单个数字的代数运算。</p>
<p>而内积(inner product)就是两个笛卡尔坐标向量的点积。</p>
<p>符号：$a \cdot b $</p>
<h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h3><p>叉积(cross product)，又称向量积(vector product)。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmgeeg3kivj31c405q3zj.jpg" alt="image-20210108170711278"></p>
<h3 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h3><p>首先介绍张量积(tensor product)，记为$\otimes$，可以应用于不同的上下文中如<a href="https://zh.wikipedia.org/wiki/向量" target="_blank" rel="noopener">向量</a>、<a href="https://zh.wikipedia.org/wiki/矩阵" target="_blank" rel="noopener">矩阵</a>、<a href="https://zh.wikipedia.org/wiki/张量" target="_blank" rel="noopener">张量</a>、<a href="https://zh.wikipedia.org/wiki/向量空间" target="_blank" rel="noopener">向量空间</a>、<a href="https://zh.wikipedia.org/wiki/代数" target="_blank" rel="noopener">代数</a>、<a href="https://zh.wikipedia.org/wiki/拓扑向量空间" target="_blank" rel="noopener">拓扑向量空间</a>和<a href="https://zh.wikipedia.org/wiki/模" target="_blank" rel="noopener">模</a> ，表示最一般的双线性运算。</p>
<p>在矩阵中就是克罗内克积(Kronecker product)：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmgeihxb8aj30eu05uglq.jpg" alt="image-20210108171101862" style="zoom:50%;"></p>
<p>在向量中就是外积(outer product)：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmgeivje1ej30nu068mxq.jpg" alt="image-20210108171128823" style="zoom:50%;"></p>
<h3 id="哈达玛积"><a href="#哈达玛积" class="headerlink" title="哈达玛积"></a>哈达玛积</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gry3kg98e4j30ve024wet.jpg" alt="image-20210628171415434"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>整数规划中的分支定界和分支切割</title>
    <url>/2019/08/28/%E6%95%B0%E5%AD%A6/%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92%E4%B8%AD%E7%9A%84%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E5%92%8C%E5%88%86%E6%94%AF%E5%88%87%E5%89%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>branch and bound： 分支定界</p>
</li>
<li><p>branch and cut：分支切割</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhhgs60g1j30lo0det98.jpg" alt="image-20200605161627142"></p>
<p>例如一个问题：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhhihzolmj30d80ao40p.jpg" alt="image-20200605161805736" style="zoom: 50%;"></p>
<p><img src="/Users/didi/Library/Application Support/typora-user-images/image-20200605161826739.png" alt="image-20200605161826739" style="zoom:67%;"></p>
<p>branch and cut： 在每个node上寻找切割不等式，最后的得到的最优解很可能大于上界，该node就被切割掉了。</p>
<p>如何选址cut不等式就是一门学问了。。有实数切割UserCut，也有整数切割LazyCut</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>拉格朗日对偶</title>
    <url>/2019/08/26/%E6%95%B0%E5%AD%A6/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>拉格朗日对偶问题的上界一定小于原问题的下界：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhhpm71pqj30rb09mac6.jpg" alt="image-20200605162458767"></p>
<ul>
<li>拉格朗日强对偶条件：</li>
</ul>
<p>对于凸问题，不等式约束严格可行，存在&lt;0， </p>
<ul>
<li>对于凸问题，KKT条件满足，则全局最优点，KKT条件是充分必要条件；对于优化问题，KKT是必要条件。</li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>可导和可微</title>
    <url>/2019/08/26/%E6%95%B0%E5%AD%A6/%E5%8F%AF%E5%AF%BC%E5%92%8C%E5%8F%AF%E5%BE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一般可导指可偏导，可微指可全微分，也就是各个方向都可偏导，存在一个与其相切的平面。</p>
<p>处处偏导又不一定可微，参考圆锥体。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhhqevzrfj30l10g3jy9.jpg" alt="image-20200605162544872"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>计算复杂度通用公式</title>
    <url>/2020/06/22/%E6%95%B0%E5%AD%A6/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算复杂度的计算存在一个通用公式，对于$T(n) = a<em>T(n / b) + c </em> n^k$ 这种，复杂度为：</p>
<p>如果$k &gt; log_b(a)$，则$T(n) = O(n^k)$</p>
<p>如果$k &lt; log_b(a)$，则$T(n) = O(n^{log_b(a)})$</p>
<p>如果$k = log_b(a)$，则$T(n) = O(n^klog(n))$</p>
<blockquote>
<p>一个例子：</p>
<p>$T(n) = 25*T(n/5) + n^2$, 则$T(n) = n^2log(n)$</p>
</blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>时间序列中的随机过程</title>
    <url>/2020/07/20/%E6%95%B0%E5%AD%A6/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E4%B8%AD%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哎，心累，上个月mac电脑进水导致硬盘坏了，写好的4-5篇博客全部丢失了，包含写好的一系列时间序列文章。懒得再码一遍了，我就贴一下之前的参考博客和课程吧。</p>
<ul>
<li><p>总结得很好的<a href="https://blog.nex3z.com/tag/time-series/" target="_blank" rel="noopener">博客</a>，包含平稳性介绍、自相关函数、偏自相关函数、ARIMA模型、指数平滑模型等知识点。</p>
</li>
<li><p>北大金融数学硕士课程：<a href="http://www.math.pku.edu.cn/teachers/lidf/course/fts/ftsnotes/html/_ftsnotes/index.html" target="_blank" rel="noopener">金融时间序列分析讲义</a> ，包含线性时间序列(ARMIA模型、指数平滑、单位根过程等)，资产波动率模型(ARCH模型，GARCH模型等)</p>
</li>
<li>北大金融数学系本科课程：<a href="http://www.math.pku.edu.cn/teachers/lidf/course/atsa/atsanotes/html/_atsanotes/index.html" target="_blank" rel="noopener">金融事件序列分析</a>，以基础为主。</li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>时间序列</tag>
      </tags>
  </entry>
  <entry>
    <title>关于PCA和SVD分解</title>
    <url>/2020/04/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8EPCA%E5%92%8CSVD%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>XGBoost和LightGBM调参</title>
    <url>/2018/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Xgboost%E5%92%8CLightGBM%E8%B0%83%E5%8F%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有个应用上的重大区别：</p>
<ul>
<li><p>Xgboost只处理数值特征，因此Xgboost无法直接处理离散特征(categorical feature)，需要数据预处理，要么labelEncoder转换为数值特征，当做连续值处理，要么one-hot编码，当做离散值处理。</p>
</li>
<li><p>LightGBM则有对离散特征的单独处理，需要首先利用labelEncoder转换为数值，然后会利用<a href="http://link.zhihu.com/?target=https%3A//www.researchgate.net/publication/242580910_On_Grouping_for_Maximum_Homogeneity" target="_blank" rel="noopener">On Grouping for Maximum Homogeneity</a>提到的算法找到最优值，是从2^(n-1)-1个分区划分中选出最优optimal split，而不像OHE一样是n个划分，因此效果优于OHE。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhgz8kjolj30hp0b7dhl.jpg" alt="image-20200605155935227"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>XGBoost</tag>
      </tags>
  </entry>
  <entry>
    <title>CART与普通决策树的区别</title>
    <url>/2019/04/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/CART%E4%B8%8E%E6%99%AE%E9%80%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CART可以说是最常用的数，gbdt,xgboost等等…</p>
<p>归纳一下其与普通决策树（ID3，C4.5）的区别：</p>
<ul>
<li>既可以分类，也可以回归。在分类时使用基尼系数，在回归时使用平方误差。</li>
<li>只划分左右子树，也就是生成一个二叉树。普通决策树生成多个子树</li>
<li>特征在被选择后，在接下来的树中还能被继续使用。普通决策树只使用特征一次。</li>
<li>连续特征，n个值，从n-1个中间值中选择；离散特征，n个值，有$2^{(n-1)} - 1$个选择可能(通常是one hot编码)。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>CART</tag>
      </tags>
  </entry>
  <entry>
    <title>XGBoost调参</title>
    <url>/2018/06/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/xgboost%E8%B0%83%E5%8F%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>选择较高的<strong>学习速率(learning rate)</strong>。一般情况下，学习速率的值为0.1。但是，对于不同的问题，理想的学习速率有时候会在0.05到0.3之间波动。选择<strong>对应于此学习速率的理想决策树数量</strong>。XGBoost有一个很有用的函数“cv”，这个函数可以在每一次迭代中使用交叉验证，并返回理想的决策树数量。</p>
</li>
<li><p>对于给定的学习速率和决策树数量，进行<strong>决策树特定参数调优</strong>(max_depth, min_child_weight, gamma, subsample, colsample_bytree)。在确定一棵树的过程中，我们可以选择不同的参数，待会儿我会举例说明。</p>
</li>
<li><p>xgboost的<strong>正则化参数</strong>的调优。(lambda, alpha)。这些参数可以降低模型的复杂度，从而提高模型的表现。</p>
</li>
<li><p>降低学习速率，确定理想参数。</p>
</li>
</ul>
<p>xgboost第n颗树的第n层的分裂准则：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhgd9bwxhj30ns0c7dj5.jpg" alt="image-20200605153827635"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>XGBoost</tag>
      </tags>
  </entry>
  <entry>
    <title>关于模型选型</title>
    <url>/2019/05/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E6%A8%A1%E5%9E%8B%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>模型可以分为高偏差/低方差和低偏差/高方差两种。前者一般指简单的模型，如生成式模型(NB)，后者一般指复杂模型，如判别式模型之类的。</p>
<p>在学习曲线上来看：</p>
<p>高偏差/低方差：训练样本很少的情况下就可以达到渐进线(低方差)，但是偏差较高，持续增加样本也没用。所以小样本的情况，建议用该类模型。</p>
<p>低偏差/高方差：训练样本很少时，容易过拟合，无法达到渐进线。当训练样本变多时，训练曲线和测试曲线达到渐进线，此时偏差又低，所以该模型适合大样本情况。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>关于特征值分布不均匀的问题</title>
    <url>/2018/12/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E7%89%B9%E5%BE%81%E5%80%BC%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前city_id作为特征后导致模型预测结果差异很大这一点，一直让我耿耿于怀，仔细思考后，其实可以这样解释：</p>
<ul>
<li><p>首先特征属性不对，我应该将其设为离散特征，做OHE处理，再放入模型训练。</p>
</li>
<li><p>特征值分布不均匀，事实上不会影响该特征值的选择，假如该特征值确实区分了样本，即使树的左右子节点样本数量相差很大，也是照样划分啊！</p>
</li>
<li><p>之前的结果很大一部分原因，还是类别分布不均匀导致的！杭州的值普遍大且样本多，宁波的值普遍小且样本少，导致结果值偏大，这就类似与分类问题正样本少，负样本多，导致结果偏向于为负。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于特征工程</title>
    <url>/2018/12/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>特征工程和模型选择是提升算法的两类途径。</p>
<ul>
<li>特征工程：数据清洗，(降维)，特征选择，特征组合。</li>
<li>特征组合变换好坏都有，一方面能提高模型的表达能力，另一方面有可能引起过拟合，增加冗余特征，降低模型解释力。<ul>
<li>特征变换还可以是将连续特征转换为离散特征。</li>
</ul>
</li>
<li>模型的选择和特征工程是耦合的。因为不同模型对特征工程的需求不一样。<ul>
<li>树模型不需要归一化处理，不需要特征选择，因为这些模型都能做到。</li>
<li>神经网络则不需要特征组合变换。</li>
<li>广义线性模型的效果则对数据清洗，特征选择，特征组合很敏感。这就是为啥计算广告领域后续衍生了FM,FFM等等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于特征归一化的一些理解</title>
    <url>/2018/11/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E7%89%B9%E5%BE%81%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>归一化会加快梯度下降法的收敛速度了</strong></p>
<p>这个是显然的，不多说了。</p>
<p>但是这里需要注意的是，像LR这种单纯的梯度下降法求解，只是增加收敛速度罢了，并不会让解更加精确，因为最终这个最优解的系数值是和特征值比例成反比的。</p>
<p><strong>归一化有可能会提升算法精度</strong></p>
<p>注意，这里是可能，因为就像前文所有，对于LR，是不会提升精度的，但是归一化对某些模型也是会提升精度的：</p>
<ul>
<li>对于KNN(跟梯度下降法无法)，需要计算欧式距离，如果不归一化，那么欧式距离就主要取决于大的特征值，从而影响精度。</li>
<li>对于有L1,L2正则的算法，如果不做归一化，那么系数值会受到特征值大小的影响，从而导致值小的特征对应的系数大，从而导致该特征受到影响。</li>
</ul>
<p>树模型不需要归一化。。。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机</title>
    <url>/2016/05/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前上了斯坦福大学Andrew Ng的机器学习课程后，以为自己的支持向量机SVM有了一番了解，只是在logistic regression上做一点改进，另外还有核函数加入拓展数据特征，然后今天看了详细的支持向量机推导过程后，才发现之前自己的理解很肤浅。</p>
<p><a href="http://taop.marchtea.com/07.02.svm.html" target="_blank" rel="noopener">这篇文章</a>详细介绍了支持向量机的概念及求解，对于更深入的SMO算法以及损耗分析，需要去看《支持向量机导论》这本书。</p>
<p>支持向量机被称为最好的监督学习分类器，我认为原因有下：</p>
<ul>
<li><p>不像logistic regression一样有$h(x)$这个logistic函数，而是</p>
<script type="math/tex; mode=display">
\begin{equation}
g(z) = 
\begin{cases}
1, &z \geq 0 \\\
-1, &z < 0
\end{cases}
\end{equation}</script></li>
<li><p>它的分类原理使得不同类别的间隔达到了最大。</p>
</li>
<li><p>对于线性不可分的情况，可以将本来的特征无限拓展到高维， 也就是系数$w$可以无限高维度，但我们却可以在求解过程中不需要知道具体维度，只要用核函数就可以求解！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>最大熵与最大似然估计</title>
    <url>/2020/05/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%80%E5%A4%A7%E7%86%B5%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>损失函数之交叉熵和MSE</title>
    <url>/2019/11/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B9%8B%E4%BA%A4%E5%8F%89%E7%86%B5%E5%92%8CMSE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一般神经网络都是用交叉熵，回归问题用MSE，分类问题用交叉熵。</p>
<p>网友分析了一下，发现MSE对梯度有个不友好的地方，有时候误差越大，梯度越小，而交叉熵是正比的。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhgeotc0dj30kb0e0wh3.jpg" alt="image-20200605153953308"></p>
<p>MSE : $A^2 * (1-A)$</p>
<p>cross entropy : A</p>
<p>另外，一般推动神经网络BP算法的时候，用的都是MSE，如果用cross entry和softmax的话，会比较复杂一点。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>类别不均衡问题的调参</title>
    <url>/2019/04/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%9D%87%E8%A1%A1%E9%97%AE%E9%A2%98%E7%9A%84%E8%B0%83%E5%8F%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于类别不均衡问题，处理方法有：</p>
<ul>
<li><p>正样本过采样</p>
</li>
<li><p>负样本降采样</p>
</li>
<li><p>调整阈值</p>
</li>
</ul>
<p>主要是这三种，实际算法处理过程往往是这样的：</p>
<ul>
<li><p>先对负样本进行降采样or正样本过采样来提取训练样本，以保证模型的AUC尽量高。</p>
</li>
<li><p>过采样or降采样之后模型输出的概率已经失去原本的意义，所以在测试集上如果看其他评价指标如交叉熵，那loss是很大的，当然不影响AUC。所以，我们需要对输出概率再做调整，恢复到真正实际的概率值。</p>
</li>
</ul>
<p>实际样例：</p>
<p>CTR预估模型之GBDT+LR：对负样本进行以w频率进行降采样，然后对预测概率值重新调整：（AUC只保序，通过calibration校正概率阈值）</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhgxszy1tj30fx02z3z3.jpg" alt="image-20200605155725174"></p>
<p>Xgboost:设置了scale_pos_weight参数，该参数的合理值= 负样本数/正样本数，该参数的意义是让正样本梯度（也就是loss）的权重值变大，也就是更加关注正样本的loss,有点类似于正样本的过采样。scale_pos_weight只适用于AUC，也就是只适用于将样本进行二分类，最终概率值并非真实概率值。</p>
<p>关于Weighted LR中正样本过采样还是正样本梯度加权重这两种方式：</p>
<blockquote>
<p>这两种训练方法得到的结果是不一样的，比如要抽样10倍，对于第一种方法，就是把一条样本重复10倍，这样优化的过程中，每遇到一条这个样本，就会用梯度更新一下参数，然后用更新后的参数再去计算下一条样本上的梯度，如果逐步计算并更新梯度10次；但对于第二种方法，则是一次性更新了单条梯度乘以10这么多的梯度，是一种一次到位的做法。</p>
<p>直观一些来讲，第一种方法更像是给予一条样本10倍的关注，愿意花更多时间和精力来对待这条样本，是一种更细致的方法，第二种则比较粗暴了，不愿意花太多功夫，直接给你10倍权重。</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>生成模型和判别模型的直观解释</title>
    <url>/2019/11/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%9B%B4%E8%A7%82%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnblogs.com/tenosdoit/p/3721074.html" target="_blank" rel="noopener">https://www.cnblogs.com/tenosdoit/p/3721074.html</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>特征是否越多越好？</title>
    <url>/2018/12/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%89%B9%E5%BE%81%E6%98%AF%E5%90%A6%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>树模型对冗余特征鲁棒性强，树模型有特征选择能力。</p>
<p>但树模型没有特征交叉组合的能力，神经网络有…</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhhcf1i1mj30o70800uh.jpg" alt="image-20200605161214027"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Github代理加速</title>
    <url>/2020/06/05/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Github%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span># 开启代理</span><br><span class="line">git config --global http.proxy 'socks5://127.0.0.1:7891'</span><br><span class="line">git config --global https.proxy 'socks5://127.0.0.1:7891'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 关闭代理</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>
<p>同时需要在你的代理软件中开启全局模式：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhkh034lhj30m40ceq7k.jpg" alt="image-20200605180018041" style="zoom:50%;"></p>
<p>注意，socks5的端口号根据代理软件设置的端口号来开(我的是7891)</p>
]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
  </entry>
  <entry>
    <title>后端技术栈</title>
    <url>/2020/11/10/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>一种将整个后端服务，按照领域、模块分解为若干独立小应用的一种架构方式。微服务有如下特点</p>
<ul>
<li>服务可以单独编写、发布、测试、部署，相比于所有功能集中于一体的单体服务，可维护性更强</li>
<li>服务彼此之间<strong>依赖服务通信的方式松耦合</strong></li>
<li>按照业务领域来组织服务，每个团队维护各自的服务</li>
</ul>
<p>引申出了RPC框架，比较有代表性的：</p>
<ul>
<li>Thrift - Facebook</li>
<li>Dubbo - 阿里</li>
<li>Spring Cloud</li>
</ul>
<p>为了更好地管理服务实例，负载均衡之类的，就需要服务注册中心：</p>
<ul>
<li>Zookeeper</li>
<li>Consul</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="关系型数据库-SQL"><a href="#关系型数据库-SQL" class="headerlink" title="关系型数据库(SQL)"></a>关系型数据库(SQL)</h4><p>代表就是MySQL，二维表结构，结构清晰</p>
<ul>
<li><p>优点：开源、体积小、成本低，支持复杂查询</p>
</li>
<li><p>缺点：高并发支持差，海量查询慢，横向拓展支持差</p>
</li>
</ul>
<h4 id="非关系型数据库-NoSQL，not-only-SQL"><a href="#非关系型数据库-NoSQL，not-only-SQL" class="headerlink" title="非关系型数据库(NoSQL，not only SQL)"></a>非关系型数据库(NoSQL，not only SQL)</h4><ul>
<li><p>Redis：KV存储，基于分布式缓存(目前一般都是基于proxy的集群化方案，zk+codis)，高性能，速度快。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkkcyfsdenj31300ocwsl.jpg" alt="image-20201015165936575"></p>
</li>
<li><p>Hbase：海量数据存储，基于列式存储，row按照key - value存</p>
</li>
<li><p>Elastic Search：倒排索引，对于模糊查询，例如查询文档中的模糊词汇，MySQL -&gt; 文档分词 -&gt; 全量contains查询，ES则存储每个单词对应的文档。</p>
</li>
</ul>
<h3 id="消息队列-MQ"><a href="#消息队列-MQ" class="headerlink" title="消息队列(MQ)"></a>消息队列(MQ)</h3><p>伴随着业务的复杂，我们往往会遇到这个场景，一个数据操作后，需要触发下游若干个子操作。例如外卖场景，用户下订单成功，要通知商家用户订单，要物流平台对订单进行调度和派单，要触发一些后置的风控逻辑对订单合法性进行校验等。如果是同步的设计，需要在订单完成后对后续的操作一一进行API调用，<strong>这样的做法让订单流程依赖更多外部服务，提升了业务复杂度，降低了服务的稳定性</strong>，所以我们需要消息中间件来解耦操作。依赖的服务依赖下单消息，而不是在下单结束后，通过接口调用的方式触发。</p>
<p>我们可以把消息队列（MQ）比作是一个存放消息的容器，Producer 负责生产消息，将消息发送到MQ，Consumer取出消息<strong>供自己使用</strong>。如图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkkcymoo3yj311y0k4wig.jpg" alt="image-20201015170419880"></p>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkkcyppscvj31bg0oagv0.jpg" alt="image-20201015170454563"></p>
<ul>
<li>Producer：产生topic</li>
<li>Parition：topic分成不同的partition处理，每个parition里保证有序</li>
<li>Replica：每个分区都有一份完整topic副本</li>
<li>Broker：启动一个Kafka就是一个Broker，多个Brokder构成一个Kafka集群</li>
<li>Consumer：消费任何Topic的数据，多个Consume组成一个消费者组。</li>
</ul>
<p>通过定义producer和consumer类，启动实例和zk就可已启动kafka服务。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul>
<li>Nginx</li>
<li>Zookeeper</li>
</ul>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><ul>
<li>基本上离线任务用MySQL+redis的存储方案可以cover大部分场景，实时任务用kafka做。</li>
<li>大厂会自己改造开源组件，字节有abase之类的</li>
<li>上面这些组件基本感觉都会设置一个中心调度器来管理，类似zookeeper这种，框架的共通性。</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
  </entry>
  <entry>
    <title>Dead ReLu问题</title>
    <url>/2019/05/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Dead%20ReLu%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原因很简单，是因为函数的负数区间值为0，导数为0，导致权重不更新。</p>
<p>但实际上，真要出现永久dead还是很严苛的：</p>
<ul>
<li>所用训练样本x在该神经元的输入值都是 &lt; 0</li>
<li>一般都是网络第一层，前面没有隐藏层。因为如果有隐藏层，隐藏层不死的话，隐藏层输出值还是会变，同样的x, 输入到该层还是有可能被激活。</li>
</ul>
<p>BP经典公式：</p>
<p>该神经元某条链路w导数 = 前面的导数累计 <em> 该神经元导数值 </em> 该链路输入值x</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>ML2020笔记-ELMO、BERT和GPT</title>
    <url>/2020/04/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ML2020%E7%AC%94%E8%AE%B0-ELMO%E3%80%81BERT%E5%92%8CGPT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>RNN-based Language Model</li>
</ul>
<p><img src="/Users/didi/Library/Application Support/typora-user-images/image-20200727110754850.png" alt="image-20200727110754850" style="zoom:50%;"></p>
<p><img src="/Users/didi/Library/Application Support/typora-user-images/image-20200727110949830.png" alt="image-20200727110949830" style="zoom:50%;"></p>
<p><img src="/Users/didi/Library/Application Support/typora-user-images/image-20200727111415304.png" alt="image-20200727111415304" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>李宏毅-ML2020</tag>
      </tags>
  </entry>
  <entry>
    <title>word2vec详解</title>
    <url>/2019/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/word2vec%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>世界级解释博客：<a href="https://blog.csdn.net/a819825294/article/details/52438625" target="_blank" rel="noopener">https://blog.csdn.net/a819825294/article/details/52438625</a></p>
<p>cbow和skip-gram的原理解析，hierarchical softmax / negative sampling， gradient descent derivation for each one.</p>
<ol>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhgkg8d7vj30uc09nagn.jpg" alt="image-20200605154521303"></li>
</ol>
<ol>
<li><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhglv7e9hj30o10lqmyw.jpg" alt="image-20200605154543836"></p>
</li>
<li></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhglw07lrj30rb07eab7.jpg" alt="image-20200605154601962"></p>
<ol>
<li><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhgluc6b6j30qs0mj0uw.jpg" alt="image-20200605154622654"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>word2vec</tag>
      </tags>
  </entry>
  <entry>
    <title>ML2020笔记-Transformer</title>
    <url>/2020/04/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ML2020%E7%AC%94%E8%AE%B0-Transformer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>李宏毅-ML2020</tag>
      </tags>
  </entry>
  <entry>
    <title>ML2020笔记-基于RNN的生成模型和Attention</title>
    <url>/2020/04/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ML2020%E7%AC%94%E8%AE%B0-%E5%9F%BA%E4%BA%8ERNN%E7%9A%84%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E5%92%8CAttention/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>李宏毅-ML2020</tag>
      </tags>
  </entry>
  <entry>
    <title>NAS系列文章解读</title>
    <url>/2020/11/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NAS%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>NAS最近几年是AutoML领域比较火热的方向，主要是神经网络结构的自动搜索。最近看了几篇NAS文章，下面按照发展历史做个总结。</p>
<p>参考博客：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/36301731" target="_blank" rel="noopener">炼丹术的终结</a></li>
<li><a href="[http://nooverfit.com/wp/%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%87%AA%E5%8A%A8%E8%AE%BE%E8%AE%A1%EF%BC%8C%E8%B0%B7%E6%AD%8C%E5%A4%A7%E8%84%91%E5%B8%AE%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%BA%86/](http://nooverfit.com/wp/你想要的神经网络自动设计，谷歌大脑帮你实现了/">你想要的神经网络自动设计，谷歌大脑帮你实现了：用参数共享高效地搜索神经网络架构（ENAS）</a>)</li>
</ul>
<h3 id="一、NAS的提出"><a href="#一、NAS的提出" class="headerlink" title="一、NAS的提出"></a>一、NAS的提出</h3><p>文献：《NEURAL ARCHITECTURE SEARCH WITH REINFORCEMENT LEARNING》</p>
<p>本质上就是确定通过一个rnn的controller，来生成神经网网络的结构。</p>
<p>例如卷积神经网络，那么无非就是要确定卷积核的数目、高、宽，stride的高和宽，也就是利用controller来生成这个五个参数。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkbtsqq13vj312a0dewmu.jpg" alt="image-20201102192353768" style="zoom:50%;"></p>
<p>controller得到5个参数的概率，然后通过sample得到网络结构，再基于该网络结构得到其在验证集上的accuracy，再利用该accuracy去更新controller的权重。这一步就类似于强化学习的policy network，我在之前的博客中也有介绍，其实本质上就是一种优化算法，当目标变量的函数未知的情况下，优化目标的一种优化算法，这里是最大化accuracy，在无法知道结构和accuracy的关系，用神经网络去逼近。</p>
<p>关于网络的深度，还是靠人为去设置的，这里的话是每sample 1600次，就将深度加深2。所以其实这个计算成本是很高的，每次深度加深，又要重新计算该模型结构的精度…文章最好的cifar-10上的最佳cnn结构是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb32ujvkrj30u00uj1ar.jpg" alt="image-20201102200659882" style="zoom:40%;"></p>
<h3 id="二、NAS的改进"><a href="#二、NAS的改进" class="headerlink" title="二、NAS的改进"></a>二、NAS的改进</h3><p>文献：《Learning Transferable Architectures for Scalable Image Recognitio》</p>
<p>原先NAS的缺点就是复杂度太高，每次都要评估生成的整个网络结构，因此本文提出一种思想：其实在经典的VGG、Inception等结构中，往往都是反复利用一种卷积结构做堆叠生成的，因此我们只需搜索这种卷积结构的最优解就行。</p>
<p>文章提出了Normal Cell和Reduce Cell，整个网络结构就是这两种cell的重复。注意，整个网络重复的次数N，还是人为拍的。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb36xh65lj30rw0zsq65.jpg" alt="image-20201102201054713" style="zoom:40%;"></p>
<p>我们只需搜索这两种cell的结构，搜索过程是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb37orljrj310l0u0tg3.jpg" alt="image-20201102201138849" style="zoom:40%;"></p>
<p>假设一个Cell里有B个block，每个block生成步骤为：</p>
<ol>
<li>从hi和hi-1或上一步中得到的隐含状态中选择一个作为输入一。</li>
<li>从从hi和hi-1或上一步中得到的隐含状态中选择一个作为输入二。（可以与第一个一样）</li>
<li>从操作集合中选择一个操作应用在输入一上。</li>
<li>从操作集合中选择一个操作应用在输入二上。</li>
<li>选择一个方法将第三步和第四步的结果合并。</li>
</ol>
<h3 id="三、PNAS"><a href="#三、PNAS" class="headerlink" title="三、PNAS"></a>三、PNAS</h3><p>文献：《Progressive Neural Architecture Search》</p>
<p>即使改进后，搜索一个神经网络结构，我们依然需要花800个GPU花4天的时间，我们可以进一步的降低复杂度。PNAS的思想是更为贪心的搜索。假设B=5，总共的复杂度为：</p>
<p>对于第一次运行生成方法，只有两个输入，因而，选取两次，得到2x2种可能。有八种operator，选取两次，得到8x8中可能，因而第一次运行该方法的空间是22x82。而对于第二次运行生成方法，operator选择的可能性没有变化，但因为上一步有一个隐含状态输出，所以输入变成了3x3中可能。以此类推，五次运行生成算法的搜索空间是：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb3ecta8pj30zk02ewfh.jpg" alt="image-20201102201802212" style="zoom:50%;"></p>
<p>而PNAS的话，我们第一步得到2^2 * 8^2 = 256种可能后，就用controller生成网络结构进行256种可能的搜索，找到top k的最优结构。然后之后第二步，就基于这top k结构来搜索，这样相当于进行了剪枝，减少了大量的计算空间。</p>
<p>整体步骤：</p>
<ul>
<li><p>完全训练生成算法第一步的所有可能的候选(256 / 2 = 136个，因为对称性)</p>
</li>
<li><p>训练启发式搜索算法</p>
</li>
<li><p>对于生成算法的后面几步的每一步：</p>
</li>
<li><ul>
<li>取得所有候选结构</li>
<li>预测候选结构在某数据集上的准确率，按照准确率排序。</li>
<li>取出准确率最高的top-K模型结构，进行训练。</li>
<li>训练启发式搜索算法</li>
</ul>
</li>
</ul>
<p>PNAS提升：模型数目减小为五分之一，而总速度降低为八分之一。</p>
<h3 id="四-、ENAS"><a href="#四-、ENAS" class="headerlink" title="四 、ENAS"></a>四 、ENAS</h3><p>文献：《Efficient Neural Architecture Search via Parameter Sharing》</p>
<p>最后是目前最常用的方法ENAS，ENAS利用参数共享的思想把复杂度提升到了原来的千分之一。ENAS的思想是把要搜索的结构想像成一个node，所有的node构成一个大的DAG，而我们要搜索的可能就是一个子图结构，但是所有node之间的权重是共享的，不需要每搜索一次子图，就重新计算子图node之间的权重。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb3qototnj31fm094gnm.jpg" alt="image-20201102202954216"></p>
<p>之前的NAS是对候选子模型逐个从头训练，事实上子模型的结构许多都是相似的，所以许多<strong>Wi,j</strong> (第i个节点与第j个节点的权重矩阵) <strong>是可以复用的</strong>，没有必要从头开始训练。这样的共享权重在文中被称作<strong>shared model</strong>。</p>
<p>最终我们要搜索的是子图，也就是红线流向：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkb3so8j7xj30ia094jrz.jpg" alt="image-20201102203149727" style="zoom:50%;"></p>
<p>再讲一下ENAS的训练，显然我们需要训练两个参数：</p>
<ul>
<li>共享权重参数</li>
<li>controller的参数</li>
</ul>
<p>整个训练过程是这样的：</p>
<ul>
<li><strong>self.train_shared()</strong> 。在模型架构固定的情况下，基于训练集，更新和共享内部参数权重<strong>Wi,j</strong>，使得内部权重得到更好收敛。</li>
<li><strong>self.train_controller()</strong> 充分使用共享的内部权重，从controller RNN中抽样出一些候选子模型，在这些模型中选择在验证集上表现最好的架构，继续步骤1的计算。</li>
</ul>
<p>相当于以前的NAS我们通过<strong>self.train_controller</strong>采样得到模型结构，然后<strong>每个模型各自训练</strong>，最后平均得到accuracy来更新controller。而ENAS的话我们采样得到模型结构后，不需要进行训练，直接基于当前共享权重，得到这些模型中表现最好的架构。然后再基于该模型架构，更新共享权重。</p>
<h3 id="五、DARTS"><a href="#五、DARTS" class="headerlink" title="五、DARTS"></a>五、DARTS</h3><p>文献：《DARTS- Differentiable Architecture Search》</p>
<p>依然是基于参数共享的理念，但是以往我们都是通过controller来控制node之间的信息流向，但是DARTS通过权重系数alpha直接来控制，不再需要controller：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkbtejwrlrj30qs0cs42u.jpg" alt="image-20201103111749052" style="zoom:50%;"></p>
<p>所以DARTS算法的流程是：</p>
<ol>
<li><p>对每个模型结构选择的地方，建立一个mixed operation。这个mixed operation有参数a（每个Node(i, j)都有一个operation维度总数的系数向量），作为权重。模型本身的参数我们设置为w</p>
</li>
<li><p>当模型还没有收敛时，做：</p>
</li>
<li><ol>
<li>更新mixed operation的模型结构参数a。使用gradient descent：grad(a, Lvalid(w<em>(a), a)). 这里的w</em>指在a结构下，训练到converge之后最佳的模型本身的参数w</li>
<li>对模型本身的参数w做gradient descent。</li>
</ol>
</li>
<li><p>如果像之前Multi Trials AutoML的方式，每次求解最后converge最佳参数w代价很高。类似ENAS，我们用单步优化的w来近似最优的w<em>，这样效率更好。因此对a的gradient变为：grad(a, Lvalid)(w - eps</em>grad(w, Ltrain(w, a), a)。实际上因为之后对w也会做gradient descent，这里直接用first order approximation即可，eps = 0，直接变为grad(a, Lvalid)(w, a)。这样每次计算量大大降低。</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkbthoiklrj31eg0bcq5f.jpg" alt="image-20201103112025371" style="zoom:50%;"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实上述这些神经网络架构搜索，也不是完全的智能搜索，还是需要人为来确定一个搜索空间，然后基于某类优化算法来求解优化问题罢了。优化算法可以有很多，比如暴力搜索、random search、贝叶斯优化、DQN、粒子群、policy network等等。像这种我们不知道x（网络架构）和y（模型准确度）这种关系的优化，用policy network的方法是一种很直观的想法。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>AutoML</category>
      </categories>
  </entry>
  <entry>
    <title>RNN的BPTT</title>
    <url>/2021/01/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RNN%E7%9A%84BPTT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RNN采用的梯度更新策略是BPTT，梯度分为两部分：</p>
<ul>
<li>竖直方向的输出层权重：这个和传统反向传播没什么区别，因为这一层的权重只与当前loss有关</li>
<li>竖直方向的输入层和水平权重：这个就稍微复杂点，因为rnn的总loss是所有时刻loss相加的，同时每个时刻的loss又会影响到这里所说的所有权重，所以操作是：<ul>
<li>计算某个时刻Et的误差项，通过反向传播来计算，最后计算梯度。</li>
<li>汇总所有的时刻计算的梯度。</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmgf10qmerj30f207ogmg.jpg" alt="image-20210108172855248" style="zoom:50%;"></p>
<p><a href="https://www.cnblogs.com/wacc/p/5341670.html" target="_blank" rel="noopener">参考资料</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>《自然语言处理入门》笔记</title>
    <url>/2020/03/20/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/%E3%80%8A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>疫情期间看完了何晗老师的《自然语言处理入门》这本书，真的是学习了很多NLP的传统知识，本文是相关的笔记。</p>
<p>何晗老师的博客：<a href="https://www.hankcs.com/" target="_blank" rel="noopener">码农场</a></p>
<h3 id="一、新手上路"><a href="#一、新手上路" class="headerlink" title="一、新手上路"></a>一、新手上路</h3><h4 id="NLP相关任务"><a href="#NLP相关任务" class="headerlink" title="NLP相关任务"></a>NLP相关任务</h4><ul>
<li><p>最基本的工具任务：词法分析：(中文)分词，词性标注和命名实体识别</p>
</li>
<li><p>信息抽取</p>
</li>
<li><p>文本分类与文本聚类</p>
</li>
<li><p>句法分析</p>
</li>
<li><p>语义分析与篇章分析</p>
</li>
<li><p>更高级任务：机器翻译、问答系统等</p>
</li>
</ul>
<h4 id="语料库"><a href="#语料库" class="headerlink" title="语料库"></a>语料库</h4><ul>
<li>中文分词语料库：<ul>
<li>1998《人民日报》，PKU语料库</li>
<li>微软亚洲研究院，MSR语料库</li>
<li>香港城市大学，CITYU语料库-繁体中文</li>
<li>台湾中央研究院，AS语料库-繁体中文</li>
</ul>
</li>
<li>词性标注：<ul>
<li>1998年《人民日报》，PKU标注集</li>
<li>国家语委语料库，863标注集</li>
<li>CTB(中文树库)语料库，CTB标注集</li>
<li>《诛仙》语料库，CTB标注集</li>
</ul>
</li>
<li>命名实体识别：<ul>
<li>1998年《人民日报》，实体：人名/地名/机构名</li>
<li>微软亚洲研究院，实体: 专有名词/时间表达式/数字表达式/度量表达式/地址表达式等5大类30个子类</li>
</ul>
</li>
<li>句法分析<ul>
<li>CTB语料库</li>
</ul>
</li>
<li>文本分类<ul>
<li>搜狗文本分类语料库，8000篇新闻</li>
</ul>
</li>
</ul>
<h4 id="开源工具"><a href="#开源工具" class="headerlink" title="开源工具"></a>开源工具</h4><ul>
<li>NLTK</li>
<li>斯坦福大学CoreNLP</li>
<li>哈工大LTP</li>
<li>HanLP</li>
</ul>
<h3 id="二、词典分词"><a href="#二、词典分词" class="headerlink" title="二、词典分词"></a>二、词典分词</h3><h4 id="总体思想"><a href="#总体思想" class="headerlink" title="总体思想"></a>总体思想</h4><p>基于词典进行分词，分词算法包括：</p>
<ul>
<li>完全切分</li>
<li>最大正向匹配</li>
<li>最大逆向匹配</li>
<li>双向最大匹配</li>
</ul>
<h4 id="存储和计算效率"><a href="#存储和计算效率" class="headerlink" title="存储和计算效率"></a>存储和计算效率</h4><p>为了提升存储和计算效率，提出了词典的四种数据结构：</p>
<ul>
<li>字典树</li>
<li>双数组字典树</li>
<li>AC自动机</li>
<li>基于双数组字典树的AC自动机</li>
</ul>
<h4 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h4><ul>
<li>停用词过滤</li>
<li>简繁转换</li>
<li>拼音转换</li>
</ul>
<p>总体而言，字典分词的缺点是无法解决歧义和OOV问题。</p>
<h3 id="三、二元语法与中文分词"><a href="#三、二元语法与中文分词" class="headerlink" title="三、二元语法与中文分词"></a>三、二元语法与中文分词</h3><ul>
<li>提出了语言模型，来解决歧义问题，例如分别计算“商品 和 服务” 与 “商品 和服 务”的概率，选择概率大的一种分词。</li>
<li>如果用假设为一阶马尔科夫过程，则为二元语法模型。</li>
<li>模型训练：统计词频，计算二元概率</li>
<li>模型预测：<ul>
<li>词语全切分</li>
<li>生成词网图</li>
<li>维特比译码，其实就是动态规划，每个上游节点都保存最短路径。</li>
</ul>
</li>
<li>缺点：还是无法解决OOV问题</li>
</ul>
<h3 id="四、隐马尔科夫模型与序列标注"><a href="#四、隐马尔科夫模型与序列标注" class="headerlink" title="四、隐马尔科夫模型与序列标注"></a>四、隐马尔科夫模型与序列标注</h3><ul>
<li>正式提出了序列标注思想，对于分词任务而言，就是设置{B、M、E、S}标注集，作为隐状态，而字符就是显状态，也称观测状态。</li>
<li>HMM由{初始概率矩阵，状态转移矩阵，发射矩阵}三部分组成。</li>
<li>HMM是生成模型，因为计算的其实就是f(x,y)的联合概率，只是用马尔科夫过程简化为了初始概率矩阵 <em> 状态转移矩阵 </em> 发射矩阵。</li>
<li>模型训练：<ul>
<li>显状态和隐状态都已知，直接计算词频，统计概率。</li>
<li>显状态已知，隐状态未知，需要用EM算法。</li>
</ul>
</li>
<li>模型预测：<ul>
<li>理论上是遍历所有y，计算最大概率的y，复杂度高。</li>
<li>维特比译码，即动态规划，每个时刻的每个状态保留最大概率路径。</li>
</ul>
</li>
<li>可以解决OOV，但是还是不够好，jieba分词就是用的HMM</li>
</ul>
<h3 id="五、感知机分类与序列标注"><a href="#五、感知机分类与序列标注" class="headerlink" title="五、感知机分类与序列标注"></a>五、感知机分类与序列标注</h3><h4 id="感知机算法"><a href="#感知机算法" class="headerlink" title="感知机算法"></a>感知机算法</h4><ul>
<li><p>模型预测：公式为 $y = sign(wx + b)$</p>
</li>
<li><p>模型训练：对于每一个训练样本：</p>
<ul>
<li>如果预测$\hat{y}$与真实$y$相等，则跳过</li>
<li>如果不相等，则$w = w + x * y$</li>
</ul>
</li>
<li><p>其实相当于损失函数为</p>
<script type="math/tex; mode=display">
L = \frac{1}{N}\sum max(0, -y^{(i)}.w.x^{(i)})</script></li>
<li><p>每次迭代的感知机参数都保留，做集成：</p>
<ul>
<li>投票感知机：每个感知机结果加权平均</li>
<li>平均感知机：每个感知机的参数直接求平均</li>
</ul>
</li>
</ul>
<h4 id="结构化感知机算法"><a href="#结构化感知机算法" class="headerlink" title="结构化感知机算法"></a>结构化感知机算法</h4><ul>
<li><p>属于结构化预测问题，例如机器翻译、序列标注等，预测结果诸如是一个序列、一颗树啊等等。此类算法往往在训练的时候，就需要做预测的工作。</p>
</li>
<li><p>定义得分函数$score(x,y) = w.\phi(x, y)$，其中$\phi(x,y)$就是特征函数，则$\hat{y} = argmax \ {score(x,y)}$</p>
</li>
<li><p>模型属于判别模型，因为最终归一化后，其实还是条件概率$p(y|x) = \frac{exp(score(x,y))}{\sum_{y}{exp(score{(x,y))}}}$，其Loss Function是</p>
<script type="math/tex; mode=display">
L(w) = max_{y}(score(x,y)) - score(x, y) \\
\frac{\delta{L(w)}}{\delta{w}} = \phi(x,\hat{y}) - \phi(x, y)</script></li>
<li><p>模型训练：对于每一个训练样本，先预测$\hat{y} = argmax \ w.\phi(x, y)$，然后对于正确的y进行奖励，对于错误的预测$\hat{y}$，进行惩罚，最终w的更新公式为</p>
<script type="math/tex; mode=display">
w = w + \phi(x, y) - \phi(x, \hat{y})</script></li>
<li><p>模型预测：同样是维特比译码。</p>
</li>
<li><p>特征提取问题：</p>
<ul>
<li><p>特征函数取值0或1 ，一般分为两类：</p>
<ul>
<li>转移特征，$f(y<em>{t-1}, y</em>{t})$ ，只跟状态值有关，N种状态的话，取值就只有$ N * (N+1)$，因为包含了初始状态BOS。</li>
<li>状态特征，$f(y<em>{t}, x</em>{t})$，只跟当前隐状态值和显状态有关。</li>
</ul>
</li>
<li><p>一般是基于特征模板生成所有特征，特征模块如：</p>
<ul>
<li><p>转移特征模板，$y_{t-1}$</p>
</li>
<li><p>状态特征模板，$x<em>{t-1}, x_t, x</em>{t-2}/x<em>{t-1}, x</em>{t-1}/x_{t}$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="六、条件随机场与序列标注"><a href="#六、条件随机场与序列标注" class="headerlink" title="六、条件随机场与序列标注"></a>六、条件随机场与序列标注</h3><ul>
<li><p>首先阐述概率图模型，概率图分为两种：</p>
<ul>
<li>有向概率图：联合概率密度$p(x,y) = \prod{p(v | \pi(v))}$，$\pi(v)$表示v的所有前驱节点</li>
<li>无向概率图：联合概率密度可以分解为所有最大团的某种函数之乘积，所谓最大团，就是团内每个节点互相连接。还可以定义虚拟的因子节点，因子节点只连接两个相邻节点，组成最小的最大团，那么联合概率密度就是所有因子节点之积：</li>
</ul>
<script type="math/tex; mode=display">
p(x,y)=\frac{1}{Z}\prod_{a}{\phi_{a}{(x_a, y_a})}</script><p>这样的话，</p>
<script type="math/tex; mode=display">
p(y|x)=\frac{1}{Z(x)}\prod_{a}{\phi_{a}{(x_a, y_a})}</script></li>
<li><p>条件随机场，就是给定输入随机变量x，求解条件概率$p(y|x)$的概率无向图。用于序列标注时，就是线性链条件随机场：</p>
<p>​                                                 <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3p0sm96tj30r20iptbs.jpg" alt="image-20200726004025174" style="zoom:50%;"></p>
</li>
<li><p>如果用虚拟因子的话，显然就只有两类因子：</p>
<ul>
<li>转移因子，发生在$y<em>t$和$y</em>{t-1}$之间，即转移特征函数</li>
<li>状态因子，发生在$y_t$和$x_t$之间，即状态特征函数</li>
</ul>
</li>
<li><p>如果某种函数定义为$w.\phi(y<em>t,y</em>{t-1},x_t)$之后，其实就和结构化感知机一模一样了：</p>
<script type="math/tex; mode=display">
p(y|x)=\frac{1}{Z(x)}exp(\sum{w.\phi(y_t,y_{t-1},x_t)})</script></li>
<li><p>条件随机场的预测：</p>
<ul>
<li>和结构化感知机一样，都是维特比译码</li>
</ul>
</li>
<li><p>条件随机场的训练：</p>
<ul>
<li><p>训练和结构化感知机不一样，因为条件随机场的Loss Function为最大似然概率，即也相当于最大(相对)熵：</p>
<script type="math/tex; mode=display">
L(w)=log(\prod{p(y|x)^{\hat{p}(x,y)}}) = \sum_{x,y}{\hat{p}(x,y)log(p(y|x))} = \sum_{i=1}^{N}{p(y^{(i)}|x^{(i)})}</script></li>
<li><p>利用梯度下降法求解的话，w参数更新公式(和结构化感知机最大的区别就在这里)：</p>
<script type="math/tex; mode=display">
w = w + \phi(x, y) - E_w[\phi(x, y)]</script></li>
</ul>
</li>
</ul>
<pre><code>- 感知机仅惩罚错得最厉害的哪一个$\hat{y}$对应的特征函数$\phi(x,\hat{y})$
- 条件随机场惩罚所有答案，总惩罚量依然为1，但是所有答案分摊，而当特征函数的经验分布期望和模型期望一致的时候，梯度为0，不需要再更新。
</code></pre><ul>
<li>条件随机场其实就是最大熵模型的衍生~可以看我之前的有关最大熵模型的博文。</li>
</ul>
<h3 id="七、词性标注"><a href="#七、词性标注" class="headerlink" title="七、词性标注"></a>七、词性标注</h3><p>本质上也是一个序列标注模型，标注方式有两种：</p>
<ul>
<li>独立模型：先进行分词任务，再进行词性标注任务，流水线。</li>
<li>联合模型：将分词任务和词性任务联合，标注集例如{B-名词，M-名词}等。<ul>
<li>优点：联合模型几乎在所有问题上优于独立模型。</li>
<li>缺点：很难有同时标注分词和词性的优秀语料库，一般而言中分分词语料库远多于词性标注语料库；还有就是，联合模型的标注集很大，导致特征数量也很大，参数爆炸。</li>
</ul>
</li>
</ul>
<h3 id="八、命名实体识别"><a href="#八、命名实体识别" class="headerlink" title="八、命名实体识别"></a>八、命名实体识别</h3><ul>
<li>同样是个序列标注模型，标注集{BMES-实体，O}。但命名实体识别任务，往往可以统计为主、规则为辅。</li>
<li>对于规则较强的命名实体，例如网址、E-mail、ISBN、商品编号等，完全可以通过正则表达式先进行预处理提取，再分词统计</li>
<li>对于较短的命名实体，例如人名，完全可以通过先分词，再词性标注即可。</li>
<li>HanLP对于一些命名实体是用规则来做的：<ul>
<li>音译人名</li>
<li>日本人名</li>
<li>数词英文实体：这个被称为原子分词，这个代码非常值得学习。</li>
</ul>
</li>
<li><strong>自定义领域的命名实体识别任务</strong><ul>
<li>Step 1：收集生语料</li>
<li>Step 2：可以先利用HanLP的词法分析器，得到分词和词性标注结果</li>
<li>Step 3：基于词法分析结果，人工标注你想要的实体，生成熟语料</li>
<li>Step 4：训练序列标注模型</li>
</ul>
</li>
</ul>
<h3 id="九、信息抽取"><a href="#九、信息抽取" class="headerlink" title="九、信息抽取"></a>九、信息抽取</h3><p>所介绍的都是无监督算法。</p>
<h4 id="新词提取"><a href="#新词提取" class="headerlink" title="新词提取"></a>新词提取</h4><p>从文章中发现新的词汇，信息熵算法：</p>
<ul>
<li>如果一个字符串左边和右边的搭配很丰富，并且字符串本身的字符搭配很固定，这大概率就是个词汇。</li>
<li>信息熵：计算某个字符串左边和右边单个字符的信息熵，设定信息熵&gt;=某个阈值</li>
<li>互信息：计算该字符串内部的所有字符之间的互信息，互信息大，说明字符都是相关的，设定互信息&gt;=某个阈值</li>
<li>取符合上诉要求的词频Top N字符串。</li>
</ul>
<h4 id="短语提取"><a href="#短语提取" class="headerlink" title="短语提取"></a>短语提取</h4><p>与新词提取相同，只是需要先进行分词，然后把：</p>
<ul>
<li>字符串 -&gt; 单词列表</li>
<li>左右的单个字符 -&gt; 单个单词</li>
</ul>
<h4 id="关键词提取"><a href="#关键词提取" class="headerlink" title="关键词提取"></a>关键词提取</h4><ul>
<li>Top N词频</li>
<li>Top N TF-IDF ：单词在本文档的词频 / 单词出现在所有文档的次数</li>
<li>TextRank：类似pageRank，基于网站之间的链接生成图，然后每个节点的权重取决于指向该节点的所有子节点，但是其他子节点的权重计算的时候会因为它指向的节点个数而减少。权重逐步迭代，最终稳定。而文本的话，就是用滑动窗口，中间单词和附近单词产生链接。</li>
</ul>
<h4 id="关键句提取"><a href="#关键句提取" class="headerlink" title="关键句提取"></a>关键句提取</h4><p>类似关键词提取，但有个TF-IDF的变种-BM25。</p>
<h3 id="十、文本聚类"><a href="#十、文本聚类" class="headerlink" title="十、文本聚类"></a>十、文本聚类</h3><h4 id="生成文档向量"><a href="#生成文档向量" class="headerlink" title="生成文档向量"></a>生成文档向量</h4><ul>
<li>词袋模型：说白了就类似one-hot，只是值换为词频。</li>
<li>布尔词频：就是one-hot</li>
<li>TF-IDF：就值换为tf-idf值</li>
<li>词向量：word2vec，然后所有词向量求和</li>
<li>自编码器：输入时词袋，文档向量就是中间的隐层向量</li>
</ul>
<h4 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h4><p>K-means算法，但是k-means有非常多的改进方法：</p>
<ul>
<li>朴素k-means: <ul>
<li>随机选取k个初始质心 -&gt; 分配簇 -&gt; 重新计算质心 -&gt; 重复</li>
<li>初始质心选取改进：先选取一个质心，然后再选取一个其他的点，如果其和最近质心的距离能够减小准则函数，再将其变为质心，以此类推，每一步都保证了准则函数的减小。</li>
</ul>
</li>
<li>更快的准则函数：将欧式距离改为余弦距离：<ul>
<li>随机选取k个初始质心 -&gt; 分配簇 -&gt; 对每个点，计算将其移入另一个簇时准则函数的增量，找出最大量并移动 -&gt; 重复</li>
</ul>
</li>
<li>层次聚类：刚开始一个簇，然后k-means分成两个，以此类推，保证二分后准则函数的gain增大，可以自动判断聚类个数。</li>
</ul>
<h3 id="十一、文本分类"><a href="#十一、文本分类" class="headerlink" title="十一、文本分类"></a>十一、文本分类</h3><p>大致思想也很简单：</p>
<ul>
<li><p>分词，提取单词；这一步并非必须，清华有个研究表明，直接提取所有相邻的n元字符，效果更好。</p>
</li>
<li><p>提取特征：词袋向量。缺点是无法表征词语之间顺序，如“不 优秀” 和 “优秀 不”。</p>
</li>
<li>特征筛选：利用卡方校验判断特征与类别之间的独立性，其实思想比较类似IV值。</li>
<li>分类模型：朴素贝叶斯、SVM等</li>
</ul>
<h3 id="十二、依存句法分析"><a href="#十二、依存句法分析" class="headerlink" title="十二、依存句法分析"></a>十二、依存句法分析</h3><p>在词法分析之后，语法分析是NLP的重要一环，也是较为高级、较为复杂的一种任务。</p>
<h4 id="短语结构树"><a href="#短语结构树" class="headerlink" title="短语结构树"></a>短语结构树</h4><ul>
<li><p>上下文无关语法/短语结构语法：句子通过语法结构生成。比如上海+名词短语 -&gt; 上海 + 浦东 + 名词短语 -&gt; 上海 + 浦东 + 机场 + 航站楼。</p>
</li>
<li><p>短语结构树：短语结构语法描述如何自顶而下生成一个句子，句子也可以通过短语结构语法来递归分解，最终生成一颗树结构。</p>
</li>
<li><p>英文树库：宾州树库PTB，中文树库：CTB。词性标注集：CTB。</p>
</li>
<li><p>20世纪90年代大部分句法分析都集中在短语结构树，由于其较为复杂，准确率并不高</p>
</li>
</ul>
<h4 id="依存句法树"><a href="#依存句法树" class="headerlink" title="依存句法树"></a>依存句法树</h4><ul>
<li>词与词之间存在主从关系，如果一个词修饰另一个词，那么称修饰词为从属词，被修饰词为支配词，两者之间的语法关系称为依存关系。比如 “大梦想”中 ，“大” 修饰 “梦想”，定中关系。</li>
<li>依存句法树4个公理：<ul>
<li>有且只有一个root虚拟根节点，不依存其他词语</li>
<li>除此外所有单词必须依存于其他单词</li>
<li>每个单词不能依存多个单词</li>
<li>如果单词A依存B，那么位置处于A和B之间的单词C只能依存于A、B或AB之间的单词</li>
</ul>
</li>
<li>开源自由的依存树库：UD(Universal Dependencies)，树库格式为CoNLL-U；CTB语料库，可以从短语结构树转化为依存句法树。</li>
<li>输入是词语和词性，输出是一颗依存句法树，算法有两类：<ul>
<li>基于图的依存句法分析：提取特征，为每条边是否属于句法树的可能性打分，然后用最大生成树作为依存句法树。缺点：开销很大</li>
<li>基于转移的依存句法分析：将树的构建过程拆分为一系列转移动作，所以只需利用自己的状态和输入单词来预测下一步要执行的转移动作，最后根据动作拼接依存句法树。<ul>
<li>Arc-Eager转移系统：定义状态集合和转移动作</li>
<li>训练：结构化感知机</li>
<li>预测：柱搜索。全局最优转移路径理论上可以通过一些动态规划(如维特比)一样来实行，但是路径过长、分支过多，在计算上不可行，因此用柱搜索：每个时刻仅仅维护分数最高的前k条子路径，k又称柱宽。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="十三、深度学习与自然语言处理"><a href="#十三、深度学习与自然语言处理" class="headerlink" title="十三、深度学习与自然语言处理"></a>十三、深度学习与自然语言处理</h3><h4 id="传统方法的局限"><a href="#传统方法的局限" class="headerlink" title="传统方法的局限"></a>传统方法的局限</h4><ul>
<li>数据稀疏，无穷多的单词，one-hot编码维度巨高且稀疏  -&gt; 深度神经网络将其化为稠密向量，相似度也会体现出来</li>
<li>特征模板，需要自己设计，且特征非常稀疏  -&gt;  深度神经网络利用多层感知器特征交叉，自动提取特征表示。</li>
<li>误差传播，例如情感分析任务：先分词、再词性标注、再SVM，多个模型的误差传播 -&gt; 深度神经网络，直接输入字符的one-hot向量，输出分类结果，端到端</li>
</ul>
<h4 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h4><ul>
<li>CBOW：输入：上下文，输出：中心词</li>
<li>Skip-Gram：输入：中心词，输出：上下文</li>
<li>更详细的介绍，可以看我之前的博客<a href="https://levylv.github.io/2019/11/04/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/word2vec%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">word2vec详解</a></li>
</ul>
<h4 id="自然语言处理进阶"><a href="#自然语言处理进阶" class="headerlink" title="自然语言处理进阶"></a>自然语言处理进阶</h4><ul>
<li><p>两个常用的特征提取器：RNN和CNN</p>
<ul>
<li>RNN，可以处理变长的输入，适合文本。特别是LSTM，可以记忆约200左右的单词。缺陷在于难以并行化。如果句子相对较短，所以在句子颗粒度上进行的基础NLP任务(中文分词、词性标注、命名实体识别和句法分析)经常用RNN</li>
<li>CNN，可以捕捉文本中的n元语法，可以并行化，考虑到文档一般较长，许多文档分类模型都是用CNN。</li>
</ul>
</li>
<li><p>词向量的研究：</p>
<ul>
<li>Fackbook-fastText，可以得到任意词语的向量，不要求词语一定出现在语料库</li>
<li>ELMO，解决一词多义，需要读入上文才才可以预测当前单词的词向量</li>
<li>Google BERT模型通过一种高效的双向transformer网络同时对上下文建模</li>
<li>基于线性模型的标注器被BiLSTM-CRF等取代<ul>
<li>其实BiILSTM+CRF模型的话，就是用BiLSTM来提取状态特征f(xi, yi)，用CRF只提取转移特征。</li>
</ul>
</li>
<li>句法分析器-BiAffineAttention</li>
<li>QA任务，归结为衡量问题和备选答案之前的文本相似度，恰好是具备注意力机制的神经网络擅长的。</li>
<li>文档摘要涉及的文本生成技术，恰好是RNN擅长的。</li>
<li>机器翻译领域，Google早已利用基于神经网络的机器翻译技术。学术界目前流行的趋势是Transformer和注意力机制提取特征。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>《自然语言处理入门》</tag>
      </tags>
  </entry>
  <entry>
    <title>理解LSI、PLSI、LDA和LFM</title>
    <url>/2020/04/25/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/%E7%90%86%E8%A7%A3LSI%E3%80%81PLSI%E3%80%81LDA%E5%92%8CLFM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>word2vec</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Policy Network</title>
    <url>/2020/10/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8Epolicy%20network/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在看NAS（neural architecture search）的论文，里面讲到了强化学习的policy network，然后我就研究了下这个东西，发现是个蛮有意思的概念，确实和nas有共同之处。有意思的点主要其实是在loss function的设计上，下面详细讲下我的理解。</p>
<p>正常来讲，我们做一个Neural Network来解决Classification or Regression task， loss function往往就是涉及一个真实label和一个esitimated label，也就是NN预测一个概率，然后拿真实的概率去做cross entropy或者等价的最大似然函数作为loss function。但是对于强化学习任务，我们通过NN预测一个动作的概率 $\pi(a|s, \theta)$，但是无法知道这个动作的真实label是什么？那要怎么来设计Loss function呢？</p>
<p>其实想法也很intuitive，Policy Network设计一个评价指标$f(a, s)$，你也可以认为是做出这个动作a之后取得的reward，然后这个loss function为：</p>
<script type="math/tex; mode=display">
L(\theta) = \sum f(a, s) log{\pi(a|s, \theta)}</script><p>其实你仔细一看，发现对比正常loss function - $\sum p(x) log{\hat{p}(x)}$，无非就是把真实label的概率换成$f(a, s)$罢了。这样的loss function其实本质上就是等价于 最大化评价指标$f(a, s)$，推到过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk7e3apzp5j312u0ju0xf.jpg" alt="image-20201030152538474" style="zoom:50%;"></p>
<p>最后，衍生到NAS上，其实本质和Policy Network是一样的。NAS里我们想要得到一个神经网络结构的概率，然后评价指标，就是用这个结构得到其在验证集上的精度。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk7e5gww8wj312e05qdhk.jpg" alt="image-20201030152746965" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>强化学习</category>
      </categories>
  </entry>
  <entry>
    <title>各语言对象和变量的关系</title>
    <url>/2020/01/07/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/%E5%90%84%E8%AF%AD%E8%A8%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="变量和对象"><a href="#变量和对象" class="headerlink" title="变量和对象"></a>变量和对象</h1><p>任何语言都是由变量和对象组成的。</p>
<p>变量和对象可能是存在一块的（变量代表内存，内存存放的的是对象二进制），也可能是分开存的，这种情况就是对象存放在其他内存，而变量存放的是那块内存的地址。</p>
<p>具体方式在不同语言中有很大区别，不同语言在底层可能做了很多优化，例如JVM的栈变量共享等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">int b = 3;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，C++的话就是分配了两个值类型变量在不同栈空间，同时分配2个对，内存各自写3。</p>
<p>而对于java，也是分配了两个值类型变量在不同栈空间，但是对象3却是在栈空间单独存在的，值类型变量都是指向这个对象3，虽说是值类型，但是存放的也是地址。但是依然是值类型，有点像python的不可变对象传递。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmvjxiyzp0j30ok0wogq5.jpg" alt="image-20210121194155398" style="zoom:50%;"></p>
<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><p>在各种语言中，变量一般分为值类型和引用类型。</p>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>变量直接存放对象的二进制数据(JVM的栈变量共享除外)，如果对变量取地址，那么就是这段内存的地址名，例如”0xc00001c100”。</p>
<p>这里的内存空间一般是栈空间，变量和对象都是在栈空间的。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型的变量存放的是对象的地址，变量位于栈空间，而对象则是位于堆空间。例如a是引用变量，其内容是”0x12335423341“，这段地址是堆空间的地址，指向堆空间的对象，而自己的地址可能是”0x51314241“，是在栈空间的地址。</p>
<p>引用类型有个巨大的好处是自动垃圾回收GC，通过引用计数可以释放没有引用的对象。</p>
<h3 id="不同语言总结"><a href="#不同语言总结" class="headerlink" title="不同语言总结"></a>不同语言总结</h3><ul>
<li><p>Java：</p>
<ul>
<li>值类型：基本数据类型int/float/short/long/double/byte/char/bool</li>
<li>引用类型：其余全是</li>
</ul>
</li>
<li><p>Python</p>
<ul>
<li>全是引用类型，python的对象基本是heap空间</li>
</ul>
</li>
<li><p>Go：</p>
<ul>
<li>值类型：基本数据类型int, float,bool, string，以及数组和struct</li>
<li>引用类型：其余全是，Go存在指针</li>
</ul>
</li>
<li><p>C++：</p>
<ul>
<li>全是值类型</li>
<li>引用类型：通过指针，引用&amp;，shared_ptr等实现。</li>
</ul>
</li>
</ul>
<h1 id="栈空间堆空间"><a href="#栈空间堆空间" class="headerlink" title="栈空间堆空间"></a>栈空间堆空间</h1><p>正如前文所说，栈空间一般是值类型的对象和变量空间，堆空间是引用变量的对象空间，堆空间一般都是new或malloc出来的，在C++中需要进行手动创建和释放，程序结束也不一定可以正确释放，容易造成内存泄漏(所以后面有类似java的shared_ptr，做引用计数的垃圾回收)。</p>
<p>除栈空间和堆空间，一般还有</p>
<ul>
<li>静态空间：存放全局变量、static变量，在程序结束会自动释放</li>
<li>常量空间：类似java的string类型，final修饰的变量</li>
<li>代码空间：存放程序代码</li>
</ul>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ul>
<li>对象分为基本数据类型和其他对象，同理变量也就分为基本数据类型的变量和引用变量</li>
<li>基本数据类型的变量操作，产生新的对象，不再指向同一个对象。变量传递相当于对象值传递。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子：int a = 3;int b;b = a; // 两个变量指向同一个栈对象a = 30; // a指向新的栈对象，b=3不会变</span><br></pre></td></tr></table></figure>
<ul>
<li>引用变量操作，还是指向同一个对象，类似C/C++的指针/引用。变量操作相当于对象地址传递。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子：Class a = new Class();Class b = new Class();b = a; // 两个变量指向同一个堆对象a.set(something); // a,b两个引用变量依然指向同一个堆对象</span><br></pre></td></tr></table></figure>
<ul>
<li>基本类型的变量和对象，引用变量都放在栈中，引用对象放在堆中。</li>
<li>栈空间的数据对象是共享的，但是堆空间是不共享的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 3; int b = 3; //这个时候3的栈对象已经存在，共享， a == b</span><br></pre></td></tr></table></figure>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ul>
<li>对象分为可变对象和不可变对象，同理变量也就分为不可变对象的变量和可变对象的变量</li>
<li>不可变对象(整型、字符串和元组)的变量操作，产生新的对象，不再指向同一个对象。变量传递相当于对象值传递。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子：a = 3; b = a; // 两个变量指向同一个对象a = 30; // a指向新的对象，b=3不会变</span><br></pre></td></tr></table></figure>
<ul>
<li>可变对象的变量操作，还是指向同一个对象，类似C/C++的指针/引用。变量操作相当于对象地址传递。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子：a = Class();b = a; // 两个变量指向同一个对象a.set(something); // a,b两个变量依然指向同一个对象</span><br></pre></td></tr></table></figure>
<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><ul>
<li>变量有变量的值和地址，对象有对象的值和地址</li>
<li>通过指针来实现对同一个对象的操作，指针的自由度更高，但是代码上相比java和python就更加复杂了，引用变量多方便啊。。</li>
<li>C/C++也有指针的高级封装-引用！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a =4 ; int &amp;b = a; b=3 //a = b = 3</span><br></pre></td></tr></table></figure>
<ul>
<li>即使是基本数据类型，也可以操作为同一个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 3;int* p = &amp;a;a = 4; // *p和a指向同一个对象</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
  </entry>
  <entry>
    <title>hive建表时的format</title>
    <url>/2018/05/30/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hive/hive%E5%BB%BA%E8%A1%A8%E6%97%B6%E7%9A%84format/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>hive建表时有三种指定，举例如下：</p>
<ul>
<li>ROW FORMAT SERDE ‘org.apache.hadoop.hive.ql.io.orc.OrcSerde’</li>
<li>STORED AS INPUTFORMAT ‘org.apache.hadoop.hive.ql.io.orc.OrcInputFormat’</li>
<li>OUTPUTFORMAT ‘org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat’</li>
</ul>
<p>对于第一种指定row format delimited，是指hive读取数据文件时的分隔符，用来划分字段，默认分隔符是’\001’。加入serde的话，是指定序列化和反序列化的一些规则，这个我就不深究了。。</p>
<p>对于第二种指定store as inputformat，就是hive加载数据时，对数据文件的处理，这里可以自定义一些方法，比如原来的数据文本分隔符是’|’，我的表指定的是’\t’，那么可以自定义方法进行正则化处理。</p>
<p>同理对于第三种指定output，就是hive输出数据时，对数据文件的处理，也可以自定义一些方法。这里注意，输入和输出的数据文件是统一的。</p>
<p>值得注意的是，无论指定何种分隔符，hive -e “select * from table “ &gt; x，x文件的分隔符都是’\t’(因为hive环境中的字段是以\t分割的，hive环境和数据文件类似于映射的关系，如果是beeline那就是|)，在excel中打开都是一格（excel需要以逗号分割csv）。如果想要以指定分隔符生成x，那么可以</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwirt <span class="keyword">local</span> <span class="keyword">directory</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'分隔符'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> *</span><br></pre></td></tr></table></figure>
<p>﻿<strong>那么对于上述举例中的三种指定，含义就是将数据文件转化为了一种更高效，压缩更好的orc文件，这个数据文件我用cat查看了一下是乱码的。。</strong></p>
<p>最后总结一下 平时建表的一些规范：</p>
<ul>
<li>如果这个表纯粹是各个数据表之间的处理，那么建议写成举例形式，orc文件毕竟高效。</li>
<li>如果这个表是从外部生成数据导入，例如python处理后生成数据导入，那么生成表是要指定分隔符： ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘分隔符’，下面两种指定不加。</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hive</category>
      </categories>
  </entry>
  <entry>
    <title>Spark名词相关理解</title>
    <url>/2020/03/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/Spark%E5%90%8D%E8%AF%8D%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="关于partition和task"><a href="#关于partition和task" class="headerlink" title="关于partition和task"></a>关于partition和task</h2><p>partition是spark RDD的操作单元，通常会把一个数据集切分成若干个partition，实现并行处理。我把它称之为需求。</p>
<p>task则是机器能提供的操作单元，一个core对应一个task，一个task处理一个partition。我把它称之为供给。</p>
<p><strong>所以，如果stage还是只有2个partition，无论怎么调节executors的资源数目，都是没有用的，active task也只有2个而已！</strong></p>
<p>关于调节partition，又分为两类：</p>
<h4 id="非spark-sql操作"><a href="#非spark-sql操作" class="headerlink" title="非spark sql操作"></a>非spark sql操作</h4><ul>
<li><em>spark.default.parallelism</em> 集团没有默认值<br>这个参数控制RDD的partition数目，但是只对于Spark SQL以外的所有Spark的stage生效，无法控制spark sql生成的分区。Spark SQL的并行度不允许用户自己指定，Spark SQL自己会默认根据hive表对应的HDFS文件的split个数自动设置Spark SQL所在的那个stage的并行度。<br><strong>然而，我们平时用到的大部分操作都是spark sql的操作，为方便后续的复杂逻辑处理，最后sql取数之后repartition处理成多个分区</strong>。</li>
</ul>
<h4 id="spark-sql操作"><a href="#spark-sql操作" class="headerlink" title="spark sql操作"></a>spark sql操作</h4><h5 id="a-普通的操作可以用repartition来做。"><a href="#a-普通的操作可以用repartition来做。" class="headerlink" title="a. 普通的操作可以用repartition来做。"></a>a. 普通的操作可以用repartition来做。</h5><h5 id="b-对于shuffle操作，也是最常见的操作，例如join，-group等。"><a href="#b-对于shuffle操作，也是最常见的操作，例如join，-group等。" class="headerlink" title="b. 对于shuffle操作，也是最常见的操作，例如join， group等。"></a>b. 对于shuffle操作，也是最常见的操作，例如join， group等。</h5><ul>
<li><em>spark.sql.shuffle.partitions</em> 集团默认是1000个<br>控制的是每个mapper端写出的partition个数，其实也就是reducer的个数，并不是mapper的个数。例如group by a,那么在每个mapper里按照a的值分成1000个partition数，写到磁盘，启动1000个reducer，每个reducer从每个mapper端拉取对应索引的partition。</li>
<li><em>spark.sql.adaptive.enabled</em><br>是否开启调整partition功能，如果开启，spark.sql.shuffle.partitions设置的partition可能会被合并到一个reducer里运行。默认开启，同时强烈建议开启。理由：更好利用单个executor的性能，还能缓解小文件问题。</li>
<li><em>spark.sql.adaptive.shuffle.targetPostShuffleInputSize</em><br>和spark.sql.adaptive.enabled配合使用，当开启调整partition功能后，当mapper端两个partition的数据合并后数据量小于targetPostShuffleInputSize时，Spark会将两个partition进行合并到一个reducer端进行处理。</li>
<li><em>spark.sql.adaptive.minNumPostShufflePartitions</em><br>当spark.sql.adaptive.enabled参数开启后，有时会导致很多分区被合并，为了防止分区过少，可以设置spark.sql.adaptive.minNumPostShufflePartitions参数，防止分区过少而影响性能。</li>
</ul>
<h2 id="调优例子"><a href="#调优例子" class="headerlink" title="调优例子"></a>调优例子</h2><p>我明明设置了minNumPostShufflePartitions参数，但是我发现某个涉及shuffle操作stage(A join B 得到C， C join D)的始终只有2个parition!</p>
<p>解决方案：这个问题原因应该是shuffle后的C导致，因为A join B的关联key值过少，远远小于minNumPostShufflePartitions这个值，导致reduce后C的partition只有2个，从而使得后面C join D的时候，mapper数也只有2个。<strong>只加了一句C.repartition(200)后问题就解决了。。</strong></p>
<h2 id="关于MapReduce的shuffle过程和Spark的shuffle算子"><a href="#关于MapReduce的shuffle过程和Spark的shuffle算子" class="headerlink" title="关于MapReduce的shuffle过程和Spark的shuffle算子"></a>关于MapReduce的shuffle过程和Spark的shuffle算子</h2><p>Hadoop是MapReduce框架，任何一个MapReduce过程都分为Mapper(程序员编写), Shuffle和Reduce(程序员编写)过程。最影响性能的就是shuffle，因为涉及到key值排序，网络传输等。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh9nktybqj30k508xq5u.jpg" alt="image-20200605112750651"></p>
<p>对于spark而言，只有两类操作，包括transform操作(从一个RDD到另一个RDD)和action操作(RDD变为结果值返回)，任何操作都是由partition构成，以典型的shuffle算子为例，其实也类似与mapper(mapper数即为partition数)和reduce(reduce数即为partiton数)过程。但是更吊的是，在mapper task里直接进行了partition，后续reduce只要按照索引从每个mapper里取对应索引的partition就好了。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfh9s51wzjj30lq07i0u3.jpg" alt="image-20200605115037216"></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Spark</category>
      </categories>
  </entry>
  <entry>
    <title>Spark中的UDF</title>
    <url>/2020/08/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/Spark%E4%B8%AD%E7%9A%84UDF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们做模型想要上线，很多时候都会借助spark的udf来实现，最近在摸索这个东西，有了一点心得记录一下。</p>
<h3 id="Hive-Spark-SQL中的UDF"><a href="#Hive-Spark-SQL中的UDF" class="headerlink" title="Hive/Spark SQL中的UDF"></a>Hive/Spark SQL中的UDF</h3><p>这种上线方式是经常会用到的，UDF分为三种：</p>
<ul>
<li>UDF：一进对应一出</li>
<li>UDTF：一进对应多出，经常遇到的就是比如一行数组数据分为多行，类似explode lateral view</li>
<li>UDAF：多进对应一出，就是聚合函数，类似sum()，count()</li>
</ul>
<p>UDF写完后直接在SQL中使用即可，一般写法又分为java和python两种：</p>
<ul>
<li>Java：这种方式比较常见，引用hadoop/spark接口即可，最终形成一个jar包，可以包含多个模块，容易管理，借助maven工具也容易进行依赖管理。</li>
<li>Python：transform(..)  using(..)的方式py的好处是线下代码直接迁移，不用大改(一般模型也是用python开发巨多)，但坏处也有：<ul>
<li>依赖py文件的问题：<strong>py文件无法打包</strong>，模块之间不能复用，不太容易管理。依赖的py文件需要手动add file上去。</li>
<li>依赖lib的问题：如果依赖第三方包，需要<strong>自定义python环境</strong>，然后打包上传，运行时选择自定义python环境。<a href="http://heloowird.com/2018/01/29/hive_python_udf/" target="_blank" rel="noopener">http://heloowird.com/2018/01/29/hive_python_udf/</a></li>
</ul>
</li>
</ul>
<h3 id="Spark中的UDF"><a href="#Spark中的UDF" class="headerlink" title="Spark中的UDF"></a>Spark中的UDF</h3><p>对于复杂的模型，例如需要特征工程之类的，我们可能就需要直接写spark代码来实现。如果核心算法有现成的spark包，例如xgboost这种还好说，如果是自己手写实现的算法，则需要将其包装成udf来实现分布式处理。</p>
<p>UDF也是支持是三种（这个我是基于pyspark的pandas udf来的）：</p>
<ul>
<li><p>一对一的scalar</p>
</li>
<li><p>多对多的Grouped Map</p>
</li>
<li><p>多对一的Grouped Aggregate</p>
</li>
</ul>
<p>同样的，这种方式也有java(确切来讲是scala)和python两种方式：</p>
<ul>
<li>Scala(Spark)：spark.udf.register(*)，基本原理是实现一个function，然后注册成udf。function里的计算就是普通的计算。</li>
<li>Python(Pyspark)：原理也是类似，有udf功能。更进一步的，spark 2.4.0之后提出了pandas udf，基于apache arrow，借助pandas向量计算的能力大幅提升计算性能，同时省去了py4j的序列化流程。<a href="https://www.jianshu.com/p/17117574a86b。python的坏处也和sql" target="_blank" rel="noopener">https://www.jianshu.com/p/17117574a86b。python的坏处也和sql</a> udf里一样，依赖问题比较蛋疼。</li>
</ul>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>UDF里的变量都是普通变量，不能是rdd，因为rdd是不能嵌套的，每个executor都在做udf计算，再来一个rdd，executor又得分发，这是不对的。</li>
<li>如果想要从hdfs里获取某个文件分发给executor做udf计算，则需要在driver里先获取该文件，然后将其变为普通变量，用sc.broadcast将其分发到每个executor上。</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>模型上线</tag>
      </tags>
  </entry>
  <entry>
    <title>hdfs文件理解</title>
    <url>/2020/11/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hive/hdfs%E6%96%87%E4%BB%B6%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HDFS是一个分布式的文件系统，利用集群来存储海量数据。hdfs路径是一个虚拟节点，下面的多个文件可能放在多台机器上，具体放在哪台机器等信息由name node节点维护。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hive</category>
      </categories>
  </entry>
  <entry>
    <title>Databus学习笔记</title>
    <url>/2020/11/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/Databus/Databus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Databus是一个低延迟、可靠的、支持事务的、保持一致性的数据变更抓取系统。</p>
<p>这块我也只是大概了解了一下，本质上想要解决的问题是：如果有一个mysql存储和一个redis缓存，mysql的变更要同步到redis里，为了保持数据的一致性，中间就加了一个databus。</p>
<p>图片解释：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkkeg24rtjj30ju0fu0tu.jpg" alt="image-20201110213021835" style="zoom:50%;"></p>
<p>变为：</p>
<p>​                                                          <img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkkeh2sv7ej30jy0ug3z9.jpg" alt="image-20201110213058927" style="zoom:50%;"></p>
<p>​       </p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Databus</category>
      </categories>
  </entry>
  <entry>
    <title>Flink学习笔记</title>
    <url>/2020/11/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/Flink/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Flink是一个分布式的流式数据处理框架，目前很多公司都开始用flink来处理流式任务（对，说的就是我司）。在Flink之前，其实我们已经有spark streaming和storm来处理流式任务，为何还要flink？下面就说吞吐量和时延上说下flink的优势，主要讲一下基本原理和容错机制。</p>
<h3 id="流框架"><a href="#流框架" class="headerlink" title="流框架"></a>流框架</h3><ul>
<li>Naive streaming： storm和flink都是naive streaming处理，这类引擎中所有的data在到来的时候就会被立即处理，一条接着一条（HINT： 狭隘的来说是一条接着一条，但流引擎有时会为提高性能缓存一小部分data然后一次性处理）。</li>
<li>Micro-batch：spark streaming是批处理的。数据流被切分为一个一个小的批次， 然后再逐个被引擎处理。这些batch一般是以时间为单位进行切分，单位一般是‘秒‘。</li>
</ul>
<p>显然， storm和flink因为是naive streaming，他们的时延性能要远远优于spark streaming。</p>
<ul>
<li>spark streaming：秒级别</li>
<li>storm：几十毫秒级别</li>
<li>flink：百毫秒级别</li>
</ul>
<p>但相对的，吞吐量上spark streaming是最大的。</p>
<h3 id="容错机制（Fault-Tolerance）"><a href="#容错机制（Fault-Tolerance）" class="headerlink" title="容错机制（Fault Tolerance）"></a>容错机制（Fault Tolerance）</h3><p>先讲下三个性质：</p>
<ul>
<li><strong>at-most-once</strong>：就是说数据只发一次，成不成功都有可能。所以这种分发方式成本最低，吞吐量和时延都很好，但是数据可能丢失，可靠性不高。</li>
<li><strong>at-least-once</strong>：数据如果不发送成功，就会多次重发尝试，需要发送端做处理，且接收端有ack机制。这种方式可能会造成数据的重复问题。</li>
<li><strong>exactly-once</strong>： 保证数据有且只有一次，接收端要做数据的去重。</li>
</ul>
<h4 id="Spark-streaming"><a href="#Spark-streaming" class="headerlink" title="Spark streaming"></a>Spark streaming</h4><p>spark依赖checkpoint机制来进行容错，只要batch执行到doCheckpoint操作前挂了，那么该batch就会被完整的重新计算。spark可以保证计算过程的exactly once（不包含sink的exactly once）。    </p>
<h4 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h4><p>storm的容错通过ack机制实现，每个bolt或spout处理完成一条data后会发送一条ack消息给acker bolt。当该条data被所有节点都处理过后，它会收到来自所有节点ack， 这样一条data处理就是成功的。storm可以保证数据不丢失，但是只能达到at least once语义。此外，因为需要每条data都做ack，所以容错的开销很大。</p>
<h4 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h4><p>flink使用Chandy-Chandy-Lamport Algorithm 来做Asynchronous Distributed Snapshots（异步分布式快照），其本质也是checkpoint。如下图，flink定时往流里插入一个barrier（隔栏），这些barriers把数据分割成若干个小的部分，当barrier流到某个operator时，operator立即会对barrier对应的一小部分数据做checkpoint并且把barrier传给下游（checkpoint操作是异步的，并不会打断数据的处理），直到所有的sink operator做完自己checkpoint后，一个完整的checkpoint才算完成。当出现failure时，flink会从最新完整的checkpoint点开始恢复。</p>
<p>flink的checkpoint机制非常轻量，barrier不会打断streaming的流动，而且做checkpoint操作也是异步的。其次，相比storm需要ack每条data，flink做的是small batch的checkpoint，容错的代价相对要低很多。最重要的是flink的checkpoint机制能保证exactly once。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkkffelsbkj30y20cwgrm.jpg" alt="image-20201110220420631" style="zoom:50%;"></p>
<p>显然，storm的容错机制需要对每条data进行ack，因此容错开销对throughputs影响巨大，throughputs下降甚至可以达到70%。</p>
<p>flink的容错机制更加轻量，处理开销少，因此相比于storm来说，flink可以达到更大的吞吐量。</p>
<h3 id="最终性能"><a href="#最终性能" class="headerlink" title="最终性能"></a>最终性能</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkkflbaoxyj30wu0f2qch.jpg" alt="image-20201110221000926" style="zoom:50%;"></p>
<p>从吞吐量和时延性能的综合来看，flink是最好的。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title>Spark笔记</title>
    <url>/2018/10/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/Spark%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>如何手动分区：<br>分两种情况，创建 RDD 时和通过转换操作得到新 RDD 时。</p>
<p>对于前者，在调用 textFile 和 parallelize 方法时候手动指定分区个数即可。例如 sc.parallelize(Array(1, 2, 3, 5, 6), 2) 指定创建得到的 RDD 分区个数为 2。</p>
<p>对于后者，直接调用 repartition 方法即可。实际上分区的个数是根据转换操作对应多个 RDD 之间的依赖关系来确定，窄依赖子 RDD 由父 RDD 分区个数决定，例如 map 操作，父 RDD 和子 RDD 分区个数一致；Shuffle 依赖则由分区器（Partitioner）决定，例如 groupByKey(new HashPartitioner(2)) 或者直接 groupByKey(2) 得到的新 RDD 分区个数等于 2。</p>
</li>
</ul>
<ul>
<li>集团的hadoop，hive，spark环境：<ul>
<li>集群在线上环境中，线下环境与之没有打通，无法连接。</li>
<li>hive有个hivejdbc接口，jdbc:hive2://10.83.16.36:8083，线下环境可以访问该ip，由此访问线上hive。</li>
<li>想要客户端访问集群，只能通过客户端，也就是各类中转机，堡垒机，D++等，同样需要装上hadoop，hive，spark等环境，并且做相关配置，例如hadoop的core-site，yarn-site，mapred-site.xml，以及spark的hive-site等。</li>
</ul>
</li>
</ul>
<ul>
<li>关于版本问题：<ul>
<li>maven的pom指定了编译打包版本(spark,java)，也是本地调试运行时的版本，此时甚至不需要本地安装java或者spark，因为pom会自动拉取该程序文件到仓库。</li>
<li>打成jar包后我们可能会到处部署，放到不同机器环境中，此时运行版本最好与编译版本保持一致，或者高于编译版本(java向下兼容)</li>
<li>对于hadoop/spark集群，无论master/slave所有机器上都要安装hadoop/spark，并且保持配置一致。</li>
<li>所以为了统一，maven的pom指定版本要与集群上安装版本一致。</li>
<li>maven clean package只是将编译产生的类打包，单独部署可能无法运行，适合作为工具包被导入；maven clean assembly:assemby还将所有依赖等文件全部打包，可以单独部署运行，最终jar包也很大，要执行这一操作需要在pom里加入assembly插件。</li>
</ul>
</li>
</ul>
<ul>
<li>spark优化相关<ul>
<li>spark的设置：程序代码 &gt; spark-submit指定 &gt; spark-default.xml</li>
<li>shuffle.partition最好设置成自动调整，使每个分区的数据尽量平均</li>
<li>数据倾斜是难以避免的，即使设置partition也没用，此时可以用map/broadcast join来避免shuffle操作，同时还有其他的一些手段例如随机前缀以及采用倾斜key等。</li>
</ul>
</li>
</ul>
<ul>
<li>spark基础操作：<ul>
<li>transformation: rdd -&gt; rdd， 注意：reduceByKey, sortByKey等都是该类操作。</li>
<li>action： rdd 返回结果给drive problem， 注意：foreach， collect, show, count, countByKey,createOrReplaceTempView是该类操作</li>
</ul>
</li>
</ul>
<ul>
<li>spark rdd处理不能嵌套！例如在对一个rdd做操作的时候，不能引入另一个rdd的操作。所以citys(Dataframe类型).foreach(func(_, data(也是Dataframe类型)))这种想法是不行的。 直观来说，就是对有分区的数据的处理时，不能再传有分区的数据。但如果单纯想要传rdd的话(不对这个rdd再做操作)，也是可以的，用broadcast变量。</li>
</ul>
<ul>
<li>rdd.foreach(x =&gt; func(x, y)) 对于这类操作，func和y都需要支持序列化和反序列化。<ul>
<li>变量y可以定义成broadcast变量，从而省去每个task序列化和反序列化的过程中，对变量y的序列化和反序列化，直接广播到了每个executor上。</li>
<li>还要注意的是，这里的func也要支持序列化，如果是自定义的func，建立放在一个支持序列化的类中。也可以直接将func写在foreach中。</li>
<li>如果func，y是引用了某个类的成员函数或变量，那么这整个类都要支持序列化，所以最好放在当前函数中。</li>
</ul>
</li>
</ul>
<ul>
<li>出现“org.apache.spark.SparkException: Task not serializable”这个错误，一般是因为在map、filter等的参数使用了外部的变量，但是这个变量不能序列化。特别是当引用了某个类（经常是当前类）的成员函数或变量时，会导致这个类的所有成员（整个类）都需要支持序列化。解决这个问题最常用的方法有：</li>
</ul>
<ol>
<li><ol>
<li>如果可以，将依赖的变量放到map、filter等的参数内部定义。这样就可以使用不支持序列化的类；</li>
<li>如果可以，将依赖的变量独立放到一个小的class中，让这个class支持序列化；这样做可以减少网络传输量，提高效率；</li>
<li>如果可以，将被依赖的类中不能序列化的部分使用transient关键字修饰，告诉编译器它不需要序列化。</li>
<li>将引用的类做成可序列化的。</li>
</ol>
</li>
</ol>
<ul>
<li>spark的worker, executor, core的概念：<ul>
<li>worker就是集群里可执行的机器，一个worker可以有多个executor。</li>
<li>一个executor就是CPU，一个CPU可以有多个核。</li>
<li>一个core(核)对应一个线程，也就是一个task，一个核同时只能执行一个task。注意，这个的core不是指物理核，是虚拟核。</li>
<li>一般来讲几个物理核就是几个线程，但是通过超线程技术，一个物理核可以分成多个虚拟核，从而使得一个核可以有多个线程。但是，一个核同时只能执行一个线程。</li>
<li>并发：多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。</li>
<li>并行：多个线程在多个核心运行，线程同时运行。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Spark</category>
      </categories>
  </entry>
  <entry>
    <title>Spark学习笔记</title>
    <url>/2020/11/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/Kafka/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Kafka是一个分布式的发布-订阅消息传递系统，其实本质就是一个分布式的日志系统，是实时任务依赖的主流数据源。注意，数据本身同样是存储在hdfs上的。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkkdxkxgi1j30wg0ion7f.jpg" alt="image-20201110211236165" style="zoom:50%;"></p>
<p>1、话题（Topic）：是特定类型的消息流。消息是字节的有效负载（Payload），话题是消息的分类名或种子（Feed）名；</p>
<p>2、生产者（Producer）：是能够发布消息到话题的任何对象；</p>
<p>3、服务代理（Broker）：一个broker就是一台机器，多台broker组成集群。</p>
<p>4、消费者（Consumer）：可以订阅一个或多个话题，并从Broker拉数据，从而消费这些已发布的消息；</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>理解存储最主要是理解partition的概念。其实Apache体系里partition的概念都比较类似（比如spark中的partition），都是将数据进行分片，一般分片的逻辑就比如是按照key值来划分，同一个key值分到同一个partition。</p>
<p>Kafka里也是将topic数据进行partition，当然每个partition的数据还是按照顺序写入的，然后将parition分配到不同broker上，partition数目一般设置成broker的倍数，这样能够让每个broker的partition均匀一点。</p>
<p>kafka的partition还会备份，leader作为主要的，follower partition放在其他broker上。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkke5hzvbgj30yw0j8jt4.jpg" alt="image-20201110212007002" style="zoom:50%;"> </p>
<p>具体存储的日志文件形式是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkke6gpqcfj310i0j8djz.jpg" alt="image-20201110212109581" style="zoom:50%;"></p>
<ul>
<li><p>每个topic下的partition都有一个文件夹。文件夹中的文件类型有.log数据文件，.index偏移量索引文件和.timeindex时间索引文件。</p>
</li>
<li><p>日志文件会被分为多个LogSegment文件，一般分段文件是1G。文件名字按照基准偏移量命名。</p>
</li>
</ul>
<p>介绍下具体的三个文件：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkke9uac8cj30u00uzn7g.jpg" alt="image-20201110212424025" style="zoom:50%;"></p>
<ul>
<li>log文件：真实的日志数据文件，存放消息payload</li>
<li>index文件：偏移量索引文件，重要的稀疏索引文件。因为如果直接去log文件里顺序查找的话，效率太低。所以现在index文件里做粗筛，定位到大致范围，然后再去log文件里找，大大提升了效率。</li>
<li>timeindex文件：时间戳索引文件的时间戳类型与日志数据文件中的时间类型是一致的，索引条目中的时间戳值及偏移量与日志数据文件中对应的字段值相同，Kafka也提供了通过时间戳索引来访问消息的方法。</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
  </entry>
  <entry>
    <title>Spark调优以及各名词深刻理解</title>
    <url>/2018/11/28/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/Spark%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Spark资源优化："><a href="#Spark资源优化：" class="headerlink" title="Spark资源优化："></a><strong>Spark资源优化：</strong></h3><p>队列是根据Fair调度分配资源的。</p>
<p>静态资源分配方式的问题： </p>
<ul>
<li>stage非对称</li>
<li>Task非对称-数据倾斜</li>
<li>执行时间随意性</li>
</ul>
<p>所以需要根据任务动态分配资源。例如：</p>
<p>Executor资源量相关：</p>
<p>spark.dynamicAllocation.minExecutors</p>
<p>spark.dynamicAllocation.maxExecutors</p>
<p>这个就会让任务根据资源需求而自动调整executors。</p>
<p>遗留参数</p>
<p>spark.executor.instances — 这个参数是老版本的，静态资源分配，不要用了。</p>
<h3 id="Spark内存优化："><a href="#Spark内存优化：" class="headerlink" title="Spark内存优化："></a><strong>Spark内存优化：</strong></h3><p>内存模型（heap就是工作用的可用内存，超过了就OOM，滴滴NodeManager指定了不超过15G，超过了就被yarn killed）</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfheqfmzdsj30nm0gkjxu.jpg" alt="image-20200605144153817" style="zoom:67%;"></p>
<p>统一内存模型：(可用内存 = 统一内存+其他，统一内存= 存储内存+计算内存)</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfheri64lbj30ux0i9dr5.jpg" alt="image-20200605144258996" style="zoom:67%;"></p>
<p>​      <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhes1vdxuj30uz0i8k3o.jpg" alt="image-20200605144331698" style="zoom:67%;"> </p>
<p>acutal used大于heap memory：因为还有overhead的开销</p>
<p>常见异常1：</p>
<ul>
<li>Executor OOM（具体其实是executor中的task超出了heap内存）<ul>
<li>heap内存不够，TASK需要更多内存(task是在这个executor上的任务，最低保障是 1/2n)</li>
</ul>
</li>
<li>解决思路<ul>
<li>增加单位Task的内存可用量<ul>
<li>增加heap的值：spark.executor.memory (java -Xmx)</li>
<li>减少单个executor的task数，即减少n，spark.executor.cores</li>
</ul>
</li>
<li>减少单位Task的内存消耗量<ul>
<li>增加partition，降低Task处理的数据，增加spark.default.parallism或者spark.sql.shuffle.partition(sql应用)</li>
<li>调整应用逻辑，降低内存使用<ul>
<li>groupByKey -&gt; reduceByKey</li>
<li>数据预处理，降低倾斜</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhet710nmj30wb0h2k0u.jpg" alt="image-20200605144437338" style="zoom:50%;"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhetjtbomj30sj0hwdql.jpg" alt="image-20200605144456476" style="zoom: 60%;"></p>
<p>常见异常2：</p>
<ul>
<li>killed by yarn<ul>
<li>Executor不存在子进程<ul>
<li>yarn监控到的container的内存为JVM内存</li>
<li>此时，killed by yarn为JVM非堆内存不足所致，也就是超过了overhead设置的内存</li>
</ul>
</li>
<li>调整方案<ul>
<li>增加overhead量<ul>
<li>spark.yarn.executor.memoryOverHead</li>
<li>scala或者java应用，默认2G能满足需求</li>
</ul>
</li>
<li>减少cores,也就是减少n</li>
</ul>
</li>
<li>Executor存在子进程<ul>
<li>container监控内存=executor内存(E) + 子进程内存（S）</li>
<li>子进程对内存资源的占用会压缩E</li>
</ul>
</li>
<li>典型场景<ul>
<li>PySpark, JVM + PVM</li>
</ul>
</li>
<li>调整方案，增加overhead量</li>
</ul>
</li>
</ul>
<h3 id="Spark-Shuffle优化："><a href="#Spark-Shuffle优化：" class="headerlink" title="Spark Shuffle优化："></a><strong>Spark Shuffle优化：</strong></h3><p>shuffle挑战：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhex22uzmj30ux0hcdmw.jpg" alt="image-20200605144817474" style="zoom:60%;"></p>
<p>I/O优化：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhexwmo8hj30g50820wh.jpg" alt="image-20200605144842117"></p>
<p>避免shuffle的broadcast hash join</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhexxv824j30th0fydmf.jpg" alt="image-20200605144901134" style="zoom:60%;"></p>
<p>缺点：很耗driver内存，例如16M的broadcast的数据，耗费100M的driver内存。</p>
<p>CBO是优化join时候的build表的，从而达到各种broadcast join / shuffle hash join(先shuffle，再broadcast)的目的， sort merge join就是我们目前经常用的。</p>
<p>​                          <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfheyd8nopj30n00exjw0.jpg" alt="image-20200605144936196" style="zoom:67%;"></p>
<p>默认不开启是为了driver内存考虑，下次可以尝试开启试一下。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Spark</category>
      </categories>
  </entry>
  <entry>
    <title>多进程，多线程以及spark的executor等概念</title>
    <url>/2018/11/07/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8Aspark%E7%9A%84executor%E7%AD%89%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在spark中，</p>
<ul>
<li>worker就是集群里可执行的机器，一个worker可以有多个executor。</li>
<li>一个executor就是CPU，一个CPU可以有多个核。</li>
<li>一个core(核)对应一个线程，也就是一个task，一个核同时只能执行一个task。注意，这个的core不是指物理核，是虚拟核。</li>
</ul>
<p>关于CPU和核：</p>
<ul>
<li>CPU有单核CPU和多核CPU。</li>
<li>一般来讲几个物理核就是几个线程，但是通过超线程技术，一个物理核可以分成多个虚拟核，从而使得一个核可以有多个线程。但是，一个核同时只能执行一个线程。</li>
<li>并发：多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。</li>
<li>并行：多个线程在多个核心运行，线程同时运行。</li>
<li>串行和并发的区别：虽然都是同时运行一个线程，但是串行就只能一个一个线程串行处理，就是一个结束了再起另一个线程，而并发本质上还是可以处理多个线程。</li>
</ul>
<p>选择多个单核CPU和单个多核CPU？</p>
<ul>
<li>多核CPU共享数据是通过CPU内部的总线，多个单核CPU共享数据是通过主板的总线，通信开销更大。</li>
<li>多核CPU只需要一套芯片组，一套存储，而多个单核CPU，每一个CPU都需要有较为独立的电路支持，有自己的Cache。如果要多个耗内存的大型程序，还是需要多个单核CPU。</li>
</ul>
<p>多进程和多线程：</p>
<ul>
<li>进程是分配资源(包括了CPU、内存、磁盘IO等)的最小单位，线程是CPU分配和调度的单位。一个进程是由多个线程组成的。其实我理解无论线程和进程都是要分配资源的，但是进程涉及的资源分配更多，而线程只涉及CPU里的资源分配，进程更加宏观，线程更加精细。</li>
<li>同一个进程内的多线程是共享资源的，因此数据共享非常方便，占用内存少，切换速度快，CPU利用率高，但是缺点就是编程较为复杂，涉及到锁之类的，同时一个线程挂导致整个进程挂，鲁棒性比较差。</li>
<li>进程之间的通信是通过管道，信号之类的，数据要共享的话涉及到共享内存，比较复杂，同时占用内存多，切换复杂，CPU利用率低，但优点就是变成简单，且进程间不受影响，鲁棒性高。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhf5zn73gj30sm0ajq97.jpg" alt="image-20200605145655675"></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>关于线程/进程的理解</title>
    <url>/2020/12/16/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近对线程有了一些的新的理解，再整理一下知识点：</p>
<ul>
<li>线程的执行单位是core，一个cpu可以有多个core，所以为啥现在计算就主打多核cpu..</li>
<li>但实际上即使是一个core，也可以实现并发，因为线程之间可以随时切换，因为有thread context这个信息，下面会提。</li>
<li>我们实现一个服务/进程，有多时候都会用多线程来并发处理，那么来看下线程的共享资源单位：<ul>
<li>代码区：毫无疑问，就是二进制的代码文件</li>
<li>动态链接库地址：就是依赖的外部库，c/c++在window是ddl，在linux是so</li>
<li>堆区：就是对象，c/c++里是new、malloc的对象，java也是new出来的对象。</li>
<li>栈区：<ul>
<li>局部变量</li>
<li>thread context，包含函数栈指针、程序计数器等，简单理解就是这个函数可能会调用多个其他函数，比如递归，那么就有个栈指针来记录这个上下文信息</li>
<li>原则上栈区是每个thread独有的，但是依旧是可以被其他thread修改，所以就有多进程里的各种线程锁之类的处理。</li>
</ul>
</li>
</ul>
</li>
<li>Spark中，一个executor可以有多个core，但是内存是按照executor来分配的，也就是core越多，多进程的话，就越吃机器的内存。内存分为memory和memoryOverHead，前者应该就是放工作数据的堆区，后者是栈区。</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>开始使用Ubuntu</title>
    <url>/2016/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Ubuntu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对linux的向往由来已久，加上前阵子在win7下用vim总是感觉很不舒服，用gcc编译还要专门去下载MinGW(minmalist GNU for Windows),这么想还不如直接去用linux，GNU下的那些工具就直接能用了！在linux下打造一个IDE吧！</p>
<blockquote>
<p>GNU’s Not Unix!</p>
</blockquote>
<p>哈哈哈，其实以前也装过一阵Ubuntu,但是那会啥都不会，四处碰壁，没用多久就泄气了。可是看了各种大牛的书后，发现windows这种操作系统都是给大牛们摸透了计算机后想办法降低门槛给小白用的，所以要是不会Linux，永远进不了真正的程序员世界。</p>
<a id="more"></a>
<p>对于linux的众多发行版中，我选择了Ubuntu 14.04 LTS，毕竟Ubuntu有不错的GUI环境（X window的gnome），我既不是忠实的GUI党也不是忠实的CLI党，我觉得选择自己最好用的才是最重要的，该GUI的时候还是得GUI（用命令行去找分区里的文件太痛苦了。。），哈哈当然CLI是超强大的！</p>
<p>大概花了两周左右的时间，将<a href="http://linux.vbird.org/" target="_blank" rel="noopener">《鸟叔的Linux私房菜之基础学习篇》</a>看了一半（实在好长。。剩下的慢慢看），然后将Ubuntu下的工作环境都部署了一遍，感觉以后大部分的工作都可以完成了。</p>
<p>这部署的过程相当纠结，当然主要还是因为我的强迫症，比如一个字体好不好看我要纠结半天，各种换啊换，每次强迫症犯的时候都好想打死自己啊！所以部署的效率实在是有点低诶。好了，话不多说，下面贴上我的配置。</p>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>装ubuntu的时候要给系统分区，我参考了鸟叔的书以及网络上的一些博客后，最后我分区如下:<br><img src="/images/my/1.png" alt="Ubuntu 分区"></p>
<p>因为我装了双系统，我把sda1,sda2,sda3三个主分区都分给了windows，sda4扩展分区分成了好多逻辑分区，分别给/boot，/，/home，/var，/usr，总共大概给Ubuntu650G左右^0^</p>
<h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><p>由于用的是校园网，学校有专门的VPN客户端，我就去学校的论坛那里下了个Ubuntu下的vpn客户端，配置简单，没费什么事就能上网了（当然，前提要设置好IP地址和DNS，连上校内网）。</p>
<h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><p>虽然进入系统后，软件更新源里默认的是中国的服务器，但我还是按照<a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">Ubuntu中文</a>的推荐换了网易，搜狐，阿里云及我们自己学校的源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#网易</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#搜狐</span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#学校</span><br><span class="line">deb http://mirrors.zju.edu.cn/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.zju.edu.cn/ubuntu/ trusty-backports restricted universe multiverse</span><br><span class="line">deb http://mirrors.zju.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.zju.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.zju.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#阿里云</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<h1 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h1><p>Ubuntu下自带的ibus输入法用起来还是不舒服，不像搜狗输入法那样将模糊语义，关键词之类的做得符合日常生活习惯，所以我还是装了搜狗输入法。</p>
<p>可以直接去<a href="http://pinyin.sogou.com/linux/" target="_blank" rel="noopener">官网</a>下载deb包，然后<code>sudo dpkg -i *.deb</code> 像搜狗输入法是需要fcitx做输入法框架的，所以安装完后需要在语言设置里将默认输入法设置为fcitx.</p>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>Ubuntu自带浏览器为firefox，但我以前用的一直都是Chrome，书签什么的同步也会方便一点的，所以毫不犹豫的换成了Chrome,<code>sudo apt-get install google-chrome-stable</code></p>
<p>flash插件问题:Chrome用的谷歌自己的flash插件，而firefox默认是没装flash插件的，所以我去abode flash player的<a href="https://get.adobe.com/cn/flashplayer/" target="_blank" rel="noopener">官网</a>手动下载了插件，教程可以看<a href="http://wiki.ubuntu.org.cn/Flash" target="_blank" rel="noopener">Ubuntu中文里的介绍</a>，Ubuntu软件中心装flash插件太坑了！安装的时候等半天根本就不动！</p>
<h1 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h1><p>看论文及查资料的时候少不了查英文单词，由于在windows里一直用有道词典，所以我先去有道官网看了一下，一看，还真有linux版本，马上下载deb包后用了一下，刚开始觉得还不错，因为有道的鼠标取词（不用划词）这个功能我实在喜欢，虽然取词反应貌似有点慢。但后来我突然发现单词无法<strong>发音</strong>！！查了各种资料还是无法解决，无奈我只能忍痛割爱。</p>
<p>然后我还是用了公认好用的星际译王，不得不说，自己可以自由添加词典，离线也能查单词确实比较强大（<em>然而现在工作基本都是联网的</em>）。具体安装及下载词典教程<a href="http://wiki.ubuntu.org.cn/index.php?title=Stardict&amp;variant=zh-cn" target="_blank" rel="noopener">看这里</a>。 </p>
<p>发音我没有装，感觉文件比较大，离线发音没必要，因为我还在Chrome下载了一个插件，我个人觉得非常好用，推荐一下，<a href="https://chrome.google.com/webstore/detail/chazd/nkiipedegbhbjmajlhpegcpcaacbfggp?hl=zh-CN" target="_blank" rel="noopener">ChaZD</a>。</p>
<h1 id="Matlab"><a href="#Matlab" class="headerlink" title="Matlab"></a>Matlab</h1><p>下载matlab估计是最让我蛋疼的事了，在windows直接找个破解版就好了，而找个linux下的破解版真是不容易，虽然好多博客都有贴下载地址，但我试了试总是下载不了，有的就是下到1G左右就不能继续下了，特别折腾，为此我还下了个BT客户端deluge(系统自带的transmission其实也挺好的)。</p>
<p>后来终于找到了一个靠谱的matlab 2010a,用wget后台下载了一天终于下好了，具体教程看<a href="ftp://wcmc.csu.edu.cn/software/%E7%A8%8B%E5%BA%8F%E8%BD%AF%E4%BB%B6/matlab/install%20matlab%20in%20linux.pdf" target="_blank" rel="noopener">这里</a>～</p>
<p>matlab下载好之后还有<a href="http://forum.ubuntu.org.cn/viewtopic.php?t=373776" target="_blank" rel="noopener">中文乱码的问题</a>还有<a href="https://forum.ubuntu.org.cn/viewtopic.php?f=122&amp;t=443586" target="_blank" rel="noopener">常见的一些安装问题</a>这两篇帖子都解决了。</p>
<h1 id="办公套件"><a href="#办公套件" class="headerlink" title="办公套件"></a>办公套件</h1><p>LibreOffice以及WPC For Linux 都试过,感觉还是不行,格式会乱,所以决定还是office文件老老实实回到windows下编辑,平时自己写文档还是用markdown生成pdf,或者latex都行。</p>
<h1 id="工程绘图"><a href="#工程绘图" class="headerlink" title="工程绘图"></a>工程绘图</h1><p>由于论文的需要，我需要一个类似MS下visio的工程绘图软件，这里我选的替代品是Dia，这个绘图软件基本能替代visio~安装很简单，也是直接<code>sudo apt-get install dia</code>，这里有个地方要注意的是，默认情况下进入dia是intergrated模式，中文显示会有问题，需要做如下修改</p>
<pre><code>sudo gedit /usr/bin/dia
#dia-normal --integrated &quot;$@&quot;
dia-normal &quot;$@&quot;
</code></pre><h1 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h1><p>Imagemagick！这个图片处理软件真的超棒！可以用import截图，用convert转换图片格式，大小，清晰，可以加滤镜等，非常好用，我直接把它当做默认图片打开方式了。安装同样<code>sudo apt-get install imagemagick</code>。</p>
<h1 id="视频，音频播放器"><a href="#视频，音频播放器" class="headerlink" title="视频，音频播放器"></a>视频，音频播放器</h1><p>Mplayer！这是号称目前这个星球上支持多媒体文件格式最多的软件！哈哈哈，反正目前我电脑里的视频音频格式它都支持，而且gnome版的界面都还不错。详细介绍及安装可以看<a href="http://wiki.ubuntu.com.cn/MPlayer" target="_blank" rel="noopener">这里</a></p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>Git的安装很方便，直接<code>sudo apt-get install git</code>，因为git本来就是linus在linux下开发的嘛～具体git的使用方法，建议看<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖老师的这篇教程</a>！</p>
<h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p>我这里直接就用ubuntu自带的gnome-terminal来使用Bash（Bourne again shell），作为一个强迫症患者，我觉得终端自带的紫底白字配色太伤眼睛了，于是上Github寻找好看的配色方案。</p>
<p>刚开始我选了solarized，想把终端配色和vim的配色都弄成solarized。</p>
<ul>
<li>终端的solarized配色文件显示，<a href="https://github.com/seebi/dircolors-solarized" target="_blank" rel="noopener">github下载</a></li>
<li>终端的solarized配色，<a href="https://github.com/Anthony25/gnome-terminal-colors-solarized" target="_blank" rel="noopener">github下载</a></li>
</ul>
<p>然而solarized配完后，总觉得看得不舒服，一时切换不过来，强迫症发作的我又去寻找其他配色。最后用了这个<a href="https://github.com/chriskempson/base16-gnome-terminal" target="_blank" rel="noopener">Git</a>.<br><img src="/images/my/2.png" alt="Ocean Light"></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu与Windows之间的远程连接</title>
    <url>/2017/06/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Ubuntu%E4%B8%8EWindows%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前使用Ubuntu 14.04时其实一直没有很好得解决远程桌面连接的问题，每次用到实验室的Windows服务器时，我都会切换到windows系统去使用。。可以说非常不方便了。这回重装Ubuntu16.04，总算是解决了这个问题，并且还解决了Windows连接Ubuntu的问题。</p>
<h1 id="Ubuntu连接Windows服务器"><a href="#Ubuntu连接Windows服务器" class="headerlink" title="Ubuntu连接Windows服务器"></a>Ubuntu连接Windows服务器</h1><p>其实Ubuntu下也有类似Windows远程连接的很方便的自带软件，那就是remmina，remmina支持很多协议，包括rdp，vnc等等，我们这里选用rdp协议来连接windows服务器。</p>
<a id="more"></a>
<p>Remmina有着简单易懂的图形界面，建立连接很简单。事实上，之前用Ubuntu 14.04时我就用过remmina，但当时碰到了一个很棘手的问题，那就是只能建立远程连接，而无法传输文件。在设置中有一个共享文件夹的选项，但是即使勾选后在windows中依然无法显示（windows服务器版本为sever 2012R）。所幸经过一番搜索，我发现了问题的解决办法，只需要利用第三方软件源将remmina进行版本更新。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-add-repository ppa:remmina-ppa-team/remmina-next</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install remmina remmina-plugin-rdp libfreerdp-plugins-standard</span><br></pre></td></tr></table></figure></p>
<p>然后再重启remmina，就可以使用共享文件夹了。</p>
<h1 id="Windows连接Ubuntu"><a href="#Windows连接Ubuntu" class="headerlink" title="Windows连接Ubuntu"></a>Windows连接Ubuntu</h1><p>实验室的工作电脑我装的是Ubuntu，但是笔记本我装的是Windows系统，并且平时笔记本一般放在寝室。为了能在寝室用笔记本连接实验室的Ubuntu(就是爱学习！),我尝试了一些办法，我觉得最好的办法就是用teamviewer!</p>
<h2 id="Teamviewer安装"><a href="#Teamviewer安装" class="headerlink" title="Teamviewer安装"></a>Teamviewer安装</h2><p>从<a href="https://www.teamviewer.com/en/download/linux/" target="_blank" rel="noopener">官网</a>下载deb文件（非商业用途的个人版本是免费的），然后执行命令（建议使用apt-get安装以解决依赖问题）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ./teamviewer*.deb</span><br></pre></td></tr></table></figure></p>
<h2 id="Teamviewer使用"><a href="#Teamviewer使用" class="headerlink" title="Teamviewer使用"></a>Teamviewer使用</h2><p>在Ubuntu中打开teamviewer后会生成了一个ID和密码，我们只要在windows段也打开teamviewer，输入该ID和密码就可以连接到Ubuntu了。注意，这种连接方式是需要联网的。</p>
<p>如果想要不联网，在内网中直接使用的话，我们需要设置<code>Extras-&gt;Options-&gt;General-&gt;Incoming LAN connections</code>选择accept exclusively,这样的话，就只会通过局域网连接了，ID也会显示为你的局域网中的ID。经过测试，我觉得teamviewer的连接速度也是挺给力的！赞！</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>重装Ubuntu16.04</title>
    <url>/2017/06/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E9%87%8D%E8%A3%85Ubuntu16.04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前的Ubuntu14.04用了快两年了，中途经过升级之类各种事，感觉系统里的一些依赖什么都被我折腾坏了，右上角总是有个软件更新冲突提示，所以决定重装Ubuntu16.04。值得一提的是，之前装完Ubuntu14.04写了一篇博客发布在简书上，博客名叫<a href="http://www.jianshu.com/p/4b9271bba240" target="_blank" rel="noopener">《开始使用Ubuntu》</a>(这篇博客也迁移到本站点中了)，至今已被阅读908次，喜欢30次，加入了一些Ubuntu专题，感觉还挺有成就感的。</p>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>有了之前使用Ubuntu14.04的经验，这次我的分区就简单了许多，主分区1,2,3给windows系统，第四个主分区变成拓展分区，拓展为<code>/boot:500M</code>(由于经常更新内核，还是需要多一点空间); <code>/:400G</code>;<code>/home:250G</code>(个人文件夹要放很多文件，所以最好单独分出来);<code>/swap:8G(大小和内存相似)</code>。</p>
<h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><p>我发现之前从校内网下载的deb包在Ubuntu16.04里无法使用，原因是因为该deb包依赖iproute，然而在我还未联网更新的Ubuntu16.04中没有iproute,iproute2取代了iproute，所以我解压了该deb包，修改了依赖项，并重新打包，然后安装完就ok了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -X xl2tpd_1.1.12-zju2_am64_new.deb test/ //解压文件</span><br><span class="line">sudo dpkg -e xl2tpd_1.1.12-zju2_am64_new.deb test/ //解压控制文件</span><br><span class="line">修改control文件</span><br><span class="line">sudo dpkg-deb -b test/ new.deb //重新打包</span><br><span class="line">sudo dpkg -i new.deb //安装</span><br></pre></td></tr></table></figure></p>
<h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><p>在software&amp;Updates里面可以进行测速，系统会自动选择一个速度最好的源，系统给我选了<code>http://ubuntu.cn99.com/ubuntu</code>这个源，保险起见我又添加了一个自己学校的源。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ZJU</span><br><span class="line">deb http://mirrors.zju.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.zju.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.zju.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.zju.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.zju.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>
<p>换好之后更新源：<code>sudo apt-get update</code></p>
<h1 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h1><p>官网下载deb文件安装即可，<code>sudo apt-get install -f</code>解决依赖问题，并且在系统语言设置出选择fcitx,添加sogo pinyin.</p>
<h1 id="Chrome浏览器"><a href="#Chrome浏览器" class="headerlink" title="Chrome浏览器"></a>Chrome浏览器</h1><p>添加第三方源并安装。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/ </span><br><span class="line">wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure></p>
<h1 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h1><p>不用多说，翻墙是必备的。为了方便起见，我选择安装图形界面的shadowsocks,即shadowsocks-qt5,详细的ss说明可参照<a href="https://github.com/shadowsocks/shadowsocks/wiki" target="_blank" rel="noopener">这里</a>,虽然代码已删，但是wiki还在。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5 //ppa即personal package archives</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure></p>
<p>下载完成后再配置ip地址等等，我买的服务器是包年100元，感觉还凑合。此外，配置好SS后，只是打开了sock5代理端口，如何让chrome用ss代理还是另一码事。</p>
<p>接下来，我们需要在chrome里安装一个插件:SwitchyOmega，插件安装后需要进行配置。首先，新建一个情景模式，然后修改为sock5协议以及配置端口。<br><img src="http://upload-images.jianshu.io/upload_images/825093-708ebfa92c818de0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="新建SS情景模式"></p>
<p>然后，我们再在自动切换这个情景模式下进行修改，首先添加一个给GFW墙掉的地址链接，该链接为<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>,由<a href="https://github.com/gfwlist/gfwlist" target="_blank" rel="noopener">github的一个项目</a>维护。然后，我们设置该地址里的url,我们用ss代理，其他url全部直接连接，这就相当于一个pac了。<br><img src="http://upload-images.jianshu.io/upload_images/825093-90aab2477f7c436f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="自动切换情景模式"></p>
<p>最后保存之后，就可以翻墙了。</p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>安装很简单，<code>sudo apt-get install git</code>,下载好之后，配置一下该电脑下的公私钥。</p>
<h1 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h1><p>不用多说，写论文必备，当做平时写文章也还行，markdown转pdf我一直都觉得挺麻烦的。。装latex无非就是编译环境和编辑器两方面，编译环境在linux下一般都用texlive，为了方便，我直接安装了全套texlive…整整3G多..<code>sudo apt-get install texlive-full</code>。</p>
<p>对于编辑器选择，我直接用的是texmaker,虽然整体来说用得不错，但我还是有点嫌弃它界面有点丑。。我查阅了其他一些流行的编辑器，如sublime,lyX等，最终还是选择了texmaker的fork版texstudio，界面之类的改进了很多，加上之前texmaker习惯大部分都适用，我觉得还是不错的。至于为什么不用vim来编辑latex，我觉得这就像我不用vim编辑markdown一样，我觉得latex及markdown都是需要实时预览，编辑起来才爽的语言，虽然vim也可以搞些插件来预览，但是一方面太麻烦，一方面vim提倡的是解放双手，远离鼠标，一旦有实时预览，双手必然会回归鼠标，我觉得这样就没有必要了，因此对于markdown和latex我都选择了其他编辑器。下图是texstudio界面：<br><img src="http://upload-images.jianshu.io/upload_images/825093-185e4118d7e48ae9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="image.png"></p>
<h2 id="中文支持"><a href="#中文支持" class="headerlink" title="中文支持"></a>中文支持</h2><p>其实latex支持中文很简单，只需在头文件处加入<code>\usepackage{ctex}</code>或者<code>\usepackage{xeCJK}</code>,然后用xelatex编译即可，中文字体也可以通过<code>\setCJKmainfont{中文字体}</code>自己设置。</p>
<h2 id="字体包问题"><a href="#字体包问题" class="headerlink" title="字体包问题"></a>字体包问题</h2><p>我在编译一个文件时用到了<code>\usapage{uarial}</code>,但是编译失败，message显示<code>File &#39;uarial.sty&#39; not found</code>，该包没有默认安装，经过google之后，我起初以为是ubuntu没有该uarial字体，于是将windows下的字体都安装到了Ubuntu中，并且还装了文泉译微米黑字体(为了好看)..<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei </span><br><span class="line">sudo apt-get install ttf-mscorefonts-installer </span><br><span class="line">sudo fc-cache -f -v //更新</span><br></pre></td></tr></table></figure></p>
<p>这么做之后并无乱用，因为问题其实是latex缺少包，而非系统缺少字体。。</p>
<p>正确做法是从CTAN下载non free fonts,也就是这些字体包不是免费的(怪不得不默认安装在latex)。。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -q http://tug.org/fonts/getnonfreefonts/install-getnonfreefonts</span><br><span class="line">sudo texlua ./install-getnonfreefonts</span><br><span class="line">sudo getnonfreefonts --sys -a</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="Matlab-R2016a"><a href="#Matlab-R2016a" class="headerlink" title="Matlab R2016a"></a>Matlab R2016a</h1><p>我分享的iso下载地址及crack破解文件:<a href="http://pan.baidu.com/s/1nuHAUCh" target="_blank" rel="noopener">百度网盘</a></p>
<h2 id="1-挂载安装"><a href="#1-挂载安装" class="headerlink" title="1. 挂载安装"></a>1. 挂载安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir /media/matlab</span><br><span class="line">sudo mount -o loop ~/Downloads/R2016a_glnxa64.iso /media/matlab/ //挂载iso到/matlab文件夹</span><br><span class="line">cd /media/matlab</span><br><span class="line">sudo ./install</span><br></pre></td></tr></table></figure>
<h2 id="2-破解激活"><a href="#2-破解激活" class="headerlink" title="2.破解激活"></a>2.破解激活</h2><ul>
<li>安装过程中选择不联网安装,输入产品密钥(crack文件中的FIK).</li>
<li>等待安装完成, 默认安装位置为/usr/local/MATLAB/R2016a.</li>
<li>安装结束后,打开matlab应用程序.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/MATLAB/R2016a/bin/glnxa64/</span><br><span class="line">sudo MATLAB</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>选择离线激活,并添加crack中的Matlab_R2016a_glnxa64.lic.</p>
<ul>
<li>将crack中的另外两个文件复制到matlab安装目录下.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp ~/Downloads/crack/libcufft.so.7.5.18 /usr/local/MATLAB/R2016a/bin/glnxa64/</span><br><span class="line"> sudo cp ~/Downloads/crack/libmwservices.so /usr/local/MATLAB/R2016a/bin/glnxa64/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-创建快捷方式"><a href="#3-创建快捷方式" class="headerlink" title="3. 创建快捷方式"></a>3. 创建快捷方式</h2><ul>
<li>由于默认PATH里不包含/usr/local/MATLAB,所以终端直接输入matlab是不行的,可以创建一个软链接<br><code>sudo ln -s /usr/local/MATLAB/R2016a/bin/glnxa64/MATLAB /usr/local/bin/matlab</code></li>
<li><p>为了更加方便,我们可以创建一个桌面快捷方式,在/usr/share/applications/下面创建一个Matlab.desktop,并添加内容如下</p>
<pre><code>  [Desktop Entry]
  Type = Application
  Name = Matlab
  GenericName = Matlab R2016a
  Comment = Matlab R2016a: The Language of the Technical Computing
  Exec = /usr/local/MATLAB/R2016a/bin/glnxa64/MATLAB -desktop //路径需自己修改
  Icon = /usr/local/MATLAB/matlab.png // 网上下载一个快捷方式图标
  StartupNotify = true
  Terminal = false
  Categories = Development;Matlab;
</code></pre><p>接着加上权限<code>sudo chmod a+x Matlab.desktop</code>.<br><a href="http://upload-images.jianshu.io/upload_images/825093-3a8333c910981276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/120" target="_blank" rel="noopener">我的快捷方式图标</a>可供下载.<br><img src="http://upload-images.jianshu.io/upload_images/825093-3a8333c910981276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/120" alt="Matlab"></p>
</li>
<li><p>为了避免每次打开matlab后存在权限问题无法读取~/.matab文件的问题，通过<code>sudo chown [your ubuntu username] -R ~/.matlab</code>改变权限。</p>
</li>
</ul>
<h2 id="4-字体和快捷键"><a href="#4-字体和快捷键" class="headerlink" title="4. 字体和快捷键"></a>4. 字体和快捷键</h2><ul>
<li>字体美化:进入Matlab，从菜单打开Preferences，打开Fonts页，把右边最下面的复选框Use antialising to smooth desktop fonts选中.</li>
<li>中文字体显示问题:可以不用很麻烦,同样打开Preferences-&gt;Fonts,挑选一个支持中文的字体就ok了,我选择的是AR PL Ukai CN(楷体)．</li>
<li>默认的快捷键是Emacs的，有点不习惯，可以Preferences-&gt;Keyboard-&gt;Shortcuts-&gt;Active settings选Windows Default set.</li>
</ul>
<hr>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>之前在Ubuntu14.04里我用octopress搭建了个人博客，重装之后我原本也是想装回octopress的，但是偶然间发现了hexo，一个更加快速、简洁且高效的博客框架！而且支持octopress的完美迁移，看了用hexo搭建的几个demo之后，我立马就决定这回使用hexo搭建个人博客了。</p>
<h2 id="安装与使用说明"><a href="#安装与使用说明" class="headerlink" title="安装与使用说明"></a>安装与使用说明</h2><p>hexo的安装和使用可以说相当得简单了，看完<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官网的介绍文档</a>我相信就立马入门了。</p>
<h2 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h2><p>当然了，安装hexo后最重要当然是选一个自己最心仪的主题（其实官网提供的landscape主题其实也还可以。。），经过一番搜索，我选择了github上hexo主题star数排名第一的next主题，附上github<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">传送门</a>，以及next作者的<a href="http://notes.iissnan.com/" target="_blank" rel="noopener">demo</a>。</p>
<p>Next的主题安装和使用也有着详细的说明文档，附上<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">传送门</a>,官网的介绍已经很详细了，我也就不在这里赘述了。</p>
<p>最后，我总结一下自己用到的hexo模块：</p>
<ul>
<li>选择Pisces主题（hexo又分为Muse, Mist, Pisces三个主题）。</li>
<li>阅读次数统计（LeanCloud）。</li>
<li>添加「标签」页面。</li>
<li>设置night bright代码高亮主题。</li>
<li>侧边栏社交链接添加微博，知乎。</li>
<li>开启打赏功能。</li>
<li>添加disqus评论系统。</li>
<li>添加local search。</li>
<li>开启MathJax，这里要注意的是，我在使用分段函数时，分段用的latex代码<code>\\</code>只被识别前一个<code>\</code>,所以要分段必须使用三个<code>\</code>。。</li>
</ul>
<hr>
<h1 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h1><p>机器学习将是我的以后工作及学习重心，tensorflow这个平台我必须快速熟悉起来。Tensorflow的安装分为无GPU(只支持CPU)和有GPU的安装，前者安装相当简单，后者的话会很麻烦，还需要对显卡驱动的各种配置。。。由于实验室的工作电脑只是集成显卡而已，所以我就选择了无GPU的安装，当然之后要是有独显了，再研究一下如何支持GPU。</p>
<p>建议使用pip直接进行安装(当然也可以通过docker，Anaconda等第三方环境安装),确保安装了python3及pip3，<code>sudo apt-get install python3-pip python3-dev</code>,然后再利用pip3就可以直接安装tensorflow无GPU支持版了，<code>pip3 install tensorflow</code>。</p>
<h2 id="Python安装numpy-scipy-matplotlib库"><a href="#Python安装numpy-scipy-matplotlib库" class="headerlink" title="Python安装numpy,scipy,matplotlib库"></a>Python安装numpy,scipy,matplotlib库</h2><p>作为python中重要的科学计算库，numpy，scipy，matplotlib库一定要正确安装。</p>
<ul>
<li>NumPy是一个定义了数值数组和矩阵类型和它们的基本运算的语言扩展。 </li>
<li>SciPy是一种使用NumPy来做高等数学、信号处理、优化、统计和许多其它科学任务的语言扩展。 </li>
<li>Matplotlib则可能是Python 2D绘图领域使用最广泛的套件。</li>
</ul>
<p>之前在windows下用pip安装scipy时，总会遇到依赖问题，我只能通过<a href="https://www.zhihu.com/question/30188492" target="_blank" rel="noopener">这篇知乎上的方法</a>，从非官方维护的第三方库安装scipy。然而在ubuntu下，不需要用pip, 直接利用<code>apt-get</code>安装，它会将依赖项自动安装，非常简单有效。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-numpy</span><br><span class="line">sudo apt-get install python-scipy</span><br><span class="line">sudo apt-get install python-matplotlib</span><br></pre></td></tr></table></figure></p>
<h2 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h2><p>由于连接国外官方pypi很慢，我的电脑大概是70kb/s左右的速度，所以最好将pip源更换为国内的镜像源，我使用的是清华大学的pip源。</p>
<p>新建<code>~/.pip/pip.conf</code>,创建内容如下:</p>
<blockquote>
<p>[global]<br>index-url = <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>系统管理工具Systemd</title>
    <url>/2021/01/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7systemd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以前linux用的是initd工具来管理系统，后来渐渐被systemd取代了。具体可看<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">这篇博客</a>，介绍得非常详细。</p>
<p>注意以下几点：</p>
<ul>
<li>systemd是可以直接与系统内核交互的，比如关机，关电源，停止cpu计算等。</li>
<li>unit是一个资源的概念，不仅仅包含service，还有很多其他的比如挂载，硬件设备等资源。</li>
<li>target是一个unit组的概念，相当于以前的run_level。比如poweroff，reboot, multi_user，graphical等状态，这些状态都对应了一系列unit的启动和关闭，一般我们都用默认状态，对应的是graphical状态。</li>
<li>我们一般都是用户自定义damen，所以要加个后缀—user，这种情况下service的符号链接是注册在~/.config/systemd/user/下的。</li>
<li>用户自定义service的话，unit配置文件只要写【Service】和【Install】就好了。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>从零搭建Mac开发环境</title>
    <url>/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mac/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAMac%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前阵子电脑mac进水，搞了台备机，重新安装了各类软件搭建开发环境，特此记录…以防万一…</p>
<h3 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h3><ol>
<li><p>Chrome</p>
</li>
<li><p>搜狗输入法</p>
</li>
<li><p>pycharm（2020.1）</p>
<ul>
<li><p>模板：Editor -&gt; File and code Templates  -&gt; Python Script：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: levylv</span></span><br><span class="line"><span class="comment"># @Date  : $&#123;DATE&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>激活 方法同idea</p>
</li>
</ul>
</li>
<li><p>Idea （2020.1）</p>
<ul>
<li><p>模板：Editor -&gt; File and code Templates  -&gt; File Header:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by levylv on $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>激活 2020.1.2破解 <a href="https://www.jianshu.com/p/46f00b2ce3ce" target="_blank" rel="noopener">https://www.jianshu.com/p/46f00b2ce3ce</a></p>
</li>
<li><p>插件 leetcode-editor <a href="https://github.com/shuzijun/leetcode-question" target="_blank" rel="noopener">https://github.com/shuzijun/leetcode-question</a> , lombok 官网下载</p>
</li>
<li><p>插件 easycode</p>
</li>
</ul>
</li>
<li><p>钉钉</p>
</li>
<li><p>dchat</p>
</li>
<li><p>微信</p>
</li>
<li><p>网易云音乐</p>
</li>
<li><p>typora</p>
<ul>
<li>ipic图床</li>
</ul>
</li>
</ol>
<h3 id="开发环境："><a href="#开发环境：" class="headerlink" title="开发环境："></a>开发环境：</h3><ol>
<li><p>Anaconda（4.8.2）</p>
<ul>
<li>新版conda自己会配置环境变量，以及激活base环境</li>
</ul>
</li>
<li><p>jdk 8</p>
<ul>
<li>配置java_home：~/.bash_profile。完整的~/.bash_profile配置看后面</li>
</ul>
</li>
<li><p>iterm2</p>
<ul>
<li>颜色配置：~/.bash_profile</li>
</ul>
</li>
<li><p>homebrew <a href="https://zhuanlan.zhihu.com/p/90508170" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/90508170</a></p>
</li>
<li><p>macvim</p>
<ul>
<li><p>brew install macvim</p>
</li>
<li><p>配置文件~/.vimrc，我的祖传配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">"Wei Lyu</span></span><br><span class="line"><span class="string">"</span>levy_lv@hotmail.com</span><br><span class="line"><span class="string">"levylv.github.io</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>====================<span class="string">"</span></span><br><span class="line"><span class="string">"</span>        通用        <span class="string">"</span></span><br><span class="line"><span class="string">"</span>====================<span class="string">"</span></span><br><span class="line"><span class="string">set nocompatible              "</span> be iMproved </span><br><span class="line">filetype plugin indent on</span><br><span class="line"><span class="built_in">set</span> nobackup <span class="string">"不备份 </span></span><br><span class="line"><span class="string">set autochdir "</span>自动切换当前目录</span><br><span class="line"></span><br><span class="line"><span class="string">"启动，语法高亮，配色</span></span><br><span class="line"><span class="string">winpos 400 200</span></span><br><span class="line"><span class="string">set lines=100 columns=150</span></span><br><span class="line"><span class="string">set laststatus=2   "</span>总是显示状态栏</span><br><span class="line"><span class="built_in">set</span> hlsearch  <span class="string">"搜索高亮</span></span><br><span class="line"><span class="string">set ignorecase "</span>搜索忽略大小写</span><br><span class="line">syntax <span class="built_in">enable</span></span><br><span class="line">syntax on</span><br><span class="line"><span class="built_in">set</span> t_Co=256</span><br><span class="line"><span class="built_in">set</span> cursorline <span class="string">"高亮光标行</span></span><br><span class="line"><span class="string">set ruler   "</span>显示光标位置状态栏</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"><span class="built_in">set</span> guifont=Monaco:h15</span><br><span class="line">colorscheme molokai</span><br><span class="line"><span class="built_in">let</span> g:molokai_original = 1</span><br><span class="line"><span class="built_in">let</span> g:rehash256 = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"Tab相关</span></span><br><span class="line"><span class="string">set tabstop=4 "</span>制表符占用空格数</span><br><span class="line"><span class="built_in">set</span> softtabstop=4 <span class="string">"将连续数量的空格视为一个制表符</span></span><br><span class="line"><span class="string">set shiftwidth=4 "</span>格式化时制表符占用空格数</span><br><span class="line"><span class="built_in">set</span> expandtab <span class="string">"制表符扩展为空格</span></span><br><span class="line"><span class="string">set cindent</span></span><br><span class="line"><span class="string">set autoindent</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>编码相关</span><br><span class="line"><span class="built_in">set</span> encoding=utf-8</span><br><span class="line"><span class="built_in">set</span> fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1</span><br><span class="line"></span><br><span class="line"><span class="string">"使用箭头导航buffer"</span></span><br><span class="line"><span class="string">"map &lt;right&gt; :bn&lt;cr&gt;</span></span><br><span class="line"><span class="string">"</span>map &lt;left&gt; :bp&lt;cr&gt;</span><br><span class="line"><span class="string">"set autowrite "</span>在切换buffer时自动保存当前的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"===================="</span></span><br><span class="line"><span class="string">"Vundle Configuration"</span></span><br><span class="line"><span class="string">"===================="</span></span><br><span class="line">filetype off                  <span class="string">" required</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> <span class="built_in">set</span> the runtime path to include Vundle and initialize</span><br><span class="line"><span class="built_in">set</span> rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle<span class="comment">#begin()</span></span><br><span class="line"><span class="string">" alternatively, pass a path where Vundle should install plugins</span></span><br><span class="line"><span class="string">"</span>call vundle<span class="comment">#begin('~/some/path/here')</span></span><br><span class="line"></span><br><span class="line"><span class="string">" let Vundle manage Vundle, required</span></span><br><span class="line"><span class="string">Plugin 'VundleVim/Vundle.vim'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> My Plugin here:</span><br><span class="line"><span class="string">" Plugin 'Valloric/YouCompleteMe'</span></span><br><span class="line"><span class="string">"</span> Plugin <span class="string">'majutsushi/tagbar'</span></span><br><span class="line"><span class="string">" Plugin 'fholgado/minibufexpl.vim'</span></span><br><span class="line"><span class="string">Plugin 'scrooloose/nerdtree'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> All of your Plugins must be added before the following line</span><br><span class="line">call vundle<span class="comment">#end()            " required</span></span><br><span class="line">filetype plugin indent on    <span class="string">" required</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>===========================<span class="string">"</span></span><br><span class="line"><span class="string">"</span>Vundle Plugin Configuration<span class="string">"</span></span><br><span class="line"><span class="string">"</span>===========================<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>minibufexpl</span><br><span class="line"><span class="string">"let g:miniBufExplMapWindowNavVim = 1 "</span>可以用&lt;C-h,j,k,l&gt;切换到上下左右的窗口 </span><br><span class="line"><span class="string">"let g:miniBufExplMapCTabSwitchBufs = 1 "</span>&lt;C-Tab&gt;,&lt;C-S-Tab&gt;切换</span><br><span class="line"><span class="string">"let g:miniBufExplModSelTarget = 1 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>NERDTree</span><br><span class="line">nnoremap &lt;Tab&gt; :NERDTreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主题molokai</p>
</li>
<li><p>vundle插件</p>
</li>
</ul>
</li>
<li><p>Maven（3.6.3） <a href="https://www.runoob.com/maven/maven-setup.html" target="_blank" rel="noopener">https://www.runoob.com/maven/maven-setup.html</a></p>
</li>
<li><p>ClashX 翻墙：<a href="https://github.com/yichengchen/clashX/releases" target="_blank" rel="noopener">https://github.com/yichengchen/clashX/releases</a></p>
</li>
<li><p>git</p>
<ul>
<li><p>~/.gitconfig配置，祖传alias配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">	name = lvwei</span><br><span class="line">	email = ***</span><br><span class="line"></span><br><span class="line">[alias]</span><br><span class="line">	a 	 = !git add . &amp;&amp; git status</span><br><span class="line">	aa       = !git add . &amp;&amp; git add -u . &amp;&amp; git status</span><br><span class="line">	ac       = !git add . &amp;&amp; git commit</span><br><span class="line">	acm      = !git add . &amp;&amp; git commit -m</span><br><span class="line">	alias    = !git config --list | grep 'alias'</span><br><span class="line">	au       = !git add -u . &amp;&amp; git status</span><br><span class="line">	c        = commit</span><br><span class="line">	ca       = commit --amend</span><br><span class="line">	cm       = commit -m</span><br><span class="line">	d        = diff</span><br><span class="line">	l        = log --graph --all --pretty=format:'%C(yellow)%h%C(cyan)%d%Creset %s %C(white)- %an, %ar%Creset'</span><br><span class="line">	lg       = log --color --graph --pretty=format:'%C(bold white)%h%Creset -%C(bold green)%d%Creset %s %C(bold green)(%cr)%Creset %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative</span><br><span class="line">	ll       = log --stat --abbrev-commit</span><br><span class="line">	llg      = log --color --graph --pretty=format:'%C(bold white)%H %d%Creset%n%s%n%+b%C(bold blue)%an &lt;%ae&gt;%Creset %C(bold green)%cr (%ci)' --abbrev-commit</span><br><span class="line">	master   = checkout master</span><br><span class="line">	s        = status</span><br><span class="line">	spull    = svn rebase</span><br><span class="line">	spush    = svn dcommit</span><br><span class="line"></span><br><span class="line">[credential]</span><br><span class="line">	helper = store</span><br><span class="line">[core]</span><br><span class="line">	excludesfile = /Users/didi/.gitignore_global</span><br></pre></td></tr></table></figure>
</li>
<li><p>.gitignore_global配置，祖传全局ignore配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Compiled <span class="built_in">source</span> <span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##################</span></span></span><br><span class="line">*.com</span><br><span class="line">*.class</span><br><span class="line">*.dll</span><br><span class="line">*.exe</span><br><span class="line">*.o</span><br><span class="line">*.so</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Packages <span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###########</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> it<span class="string">'s better to unpack these files and commit the raw source</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git has its own built <span class="keyword">in</span> compression methods</span></span><br><span class="line">*.7z</span><br><span class="line">*.dmg</span><br><span class="line">*.gz</span><br><span class="line">*.iso</span><br><span class="line">*.jar</span><br><span class="line">*.rar</span><br><span class="line">*.tar</span><br><span class="line">*.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"> Logs and databases <span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################</span></span></span><br><span class="line">*.log</span><br><span class="line">*.sql</span><br><span class="line">*.sqlite</span><br><span class="line"><span class="meta">#</span><span class="bash"> OS generated files <span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################</span></span></span><br><span class="line">.DS_Store</span><br><span class="line">.DS_Store?</span><br><span class="line">.idea</span><br><span class="line">._*</span><br><span class="line">.Spotlight-V100</span><br><span class="line">.Trashes</span><br><span class="line">Icon?</span><br><span class="line">ehthumbs.db</span><br><span class="line">Thumbs.db</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>~/.bash_profile配置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">alias</span></span></span><br><span class="line">alias ll='ls -lF'</span><br><span class="line">alias vi='mvim'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> iterm2</span></span><br><span class="line">export CLICOLOR=1</span><br><span class="line">export LSCOLOR=Gxfxaxdxcxegedabagacad</span><br><span class="line">export PS1='\[\e[01;33m\][\[\e[01;36m\]\u\[\e[01;33m\]@\[\e[01;35m\]\h\[\e[01;33m\]] \[\e[01;36m\]\w \[\e[01;32m\]\$\[\033[00m\] ' #显示全部路径名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> JAVAHOME</span></span><br><span class="line">export JAVA_HOME=$(/usr/libexec/java_home)</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Maven</span></span><br><span class="line">export MAVEN_HOME=/usr/local/apache-maven-3.6.3</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> bash shell</span></span><br><span class="line">export BASH_SILENCE_DEPRECATION_WARNING=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> !! Contents within this block are managed by <span class="string">'conda init'</span> !!</span></span><br><span class="line">__conda_setup="$('/opt/anaconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)"</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    eval "$__conda_setup"</span><br><span class="line">else</span><br><span class="line">    if [ -f "/opt/anaconda3/etc/profile.d/conda.sh" ]; then</span><br><span class="line">        . "/opt/anaconda3/etc/profile.d/conda.sh"</span><br><span class="line">    else</span><br><span class="line">        export PATH="/opt/anaconda3/bin:$PATH"</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span></span><br><span class="line">export PATH=/opt/anaconda3/bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>tmux配置, ~/.tmux.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setw -g mode-keys vi</span><br><span class="line">new-session -n $HOST</span><br><span class="line">set-option -g status-interval 1</span><br><span class="line">set-option -g automatic-rename on</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span>-option -g automatic-rename-format <span class="string">'#(basename "#&#123;pane_current_path&#125;")'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">select last window</span></span><br><span class="line">bind-key C-l select-window -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">up</span></span><br><span class="line">bind-key k select-pane -U</span><br><span class="line"><span class="meta">#</span><span class="bash">down</span></span><br><span class="line">bind-key j select-pane -D</span><br><span class="line"><span class="meta">#</span><span class="bash">left</span></span><br><span class="line">bind-key h select-pane -L</span><br><span class="line"><span class="meta">#</span><span class="bash">right</span></span><br><span class="line">bind-key l select-pane -R</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> resize pane</span></span><br><span class="line">bind -r ^k resizep -U 1 # upward (prefix Ctrl+k)</span><br><span class="line">bind -r ^j resizep -D 1 # downward (prefix Ctrl+j)</span><br><span class="line">bind -r ^h resizep -L 1 # to the left (prefix Ctrl+h)</span><br><span class="line">bind -r ^l resizep -R 1 # to the right (prefix Ctrl+l)</span><br><span class="line">bind % split-window -h -c "#&#123;pane_current_path&#125;"</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Mac</category>
      </categories>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2018/11/19/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List stringArrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">List integerArrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line"></span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123; Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>); &#125;  --相同</span><br></pre></td></tr></table></figure>
<p><strong>泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic obj)</span></span>&#123; Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey()); &#125;</span><br><span class="line"></span><br><span class="line">Generic gInteger = <span class="keyword">new</span> Generic(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">Generic gNumber = <span class="keyword">new</span> Generic(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cannot be applied to Generic&lt;java.lang.Number&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// showKeyValue(gInteger);</span></span><br></pre></td></tr></table></figure>
<p><strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong>。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>POJO、JavaBean和SpringBean</title>
    <url>/2020/05/09/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/POJO%E3%80%81JavaBean%E5%92%8CSpringBean/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h2><p>普通JAVA类，专指只有setter / getter / toString的简单类，包括DO/DTO/BO/VO等。</p>
<p>POJO是一个简单的、普通Java对象，特点是有private的属性和public的getter、setter，除此之外不具有任何特殊角色，不继承或不实现任何其它Java框架的类或接口。 </p>
<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p><strong>为了方便开发，约定的一种java类的规范！</strong>，</p>
<ul>
<li>所有属性为private。</li>
<li>这个类必须具有一个公共的(public)无参构造函数</li>
<li>private属性必须提供public的getter和setter来给外部访问，并且方法的命名也必须遵循一定的命名规范。 。</li>
<li>这个类应是可序列化的，要实现serializable接口。</li>
</ul>
<p>没有其他业务逻辑的javaBean,就是一个POJO</p>
<h2 id="SpringBean"><a href="#SpringBean" class="headerlink" title="SpringBean"></a>SpringBean</h2><p>SpringBean是受Spring管理的对象。所有能受Spring容器管理的对象，都可以成为SpringBean。</p>
<p>Spring容器对Bean没有特殊要求，不像JavaBean 一样遵循一些规范（不过对于通过设值方法注入的Bean,一定要提供setter 方法。）</p>
<p>传统的的Javabean，如果我们要创建一个 Bean，我们就要使用关键字 New。<br>但是，在 Spring 中，Bean 的创建是由 Spring 容器进行的，也就是说，在 Spring 中使用 Bean 的时候，不是由关键字 New 来创建实例了, 由Spring容器管理其生命周期行为，</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>java I/O</title>
    <url>/2019/06/11/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/java%20IO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>多线程（同步阻塞）；</li>
<li>IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）；</li>
<li>直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。</li>
</ol>
<p>NIO就是IO多路复用，同步非阻塞，selector用来监听channel(OS内核空间)，另有ByteBuffer可读可写，处理程序数据空间。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhifritq9j30pd0elafo.jpg" alt="image-20200605165005503"> </p>
<p>字节流操作，无输入输出缓存，所以一般包一个bufferedInputStream，bufferedOutputStream</p>
<p>字符流操作，自带缓存。</p>
<p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">https://www.zhihu.com/question/19732473</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>hash数据结构原理</title>
    <url>/2020/03/08/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/hash%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>java hashMap底层实现：数组+链表+红黑树(链表长度大于8的时候)</p>
<p>hashcode 通过hash函数 —&gt; hash值</p>
<p>hash值 通过数组长度取余 —&gt; index</p>
<p>所以说hash函数要尽量能够均匀数组位置。</p>
<p>java里的hashMap的hash函数是：Hash值=（hashcode）^ (hashcode &gt;&gt;&gt; 16)</p>
<p>hashMap预设数组长度也蛮重要，到load_factor(默认0.75)后，会resize 2倍，index都得重新算了。</p>
<p>python里dict对string的hash函数就很蛋疼，是64位的整数。</p>
<p>虽然hash的查询，插入，删除都很快，因为hash里的数组填不满，所以说hash相对其他数据结构而言，比较耗内存，且resize很慢。有点像空间换时间。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>关于阻塞非阻塞，同步异步的最好解释</title>
    <url>/2019/10/17/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/%E5%85%B3%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E7%9A%84%E6%9C%80%E5%A5%BD%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>还是不同层次的问题……<br>一个网络包从应用程序A发到另一台电脑上的应用程序B，需要经历：</p>
<ol>
<li>从A的业务代码到A的软件框架</li>
<li>从A的软件框架到计算机的操作系统内核</li>
<li>从A所在计算机的内核到网卡</li>
<li>从网卡经过网线发到交换机等设备，层层转发，到达B所在计算机的网卡</li>
<li>从B所在计算机的网卡到B所在计算机的内核</li>
<li>从B所在计算机的内核到B的程序的用户空间</li>
<li>从B的软件框架到B的业务代码</li>
</ol>
<p>这个层级关系就像是过程调用一样，前一级调用后一级的功能，后一级返回一个结果给前一级（比如：成功，或者失败）。只有在单独一级的调用上，可以说同步还是异步的问题。所谓同步，是指调用协议中结果在调用完成时返回，这样调用的过程中参与双方都处于一个状态同步的过程。而异步，是指调用方发出请求就立即返回，请求甚至可能还没到达接收方，比如说放到了某个缓冲区中，等待对方取走或者第三方转交；而结果，则通过接收方主动推送，或调用方轮询来得到。</p>
<p>从这个定义中，我们看：</p>
<ul>
<li><p>首先1和7：这取决于软件框架的设计，如果软件框架可以beginXXX，然后立即返回，这就是一种异步调用，再比如javascript当中的异步HTTP调用，传入参数时提供一个回调函数，回调函数在完成时调用，再比如协程模型，调用接口后马上切换到其他协程继续执行，在完成时由框架切换回到协程中，这都是典型的异步接口设计。</p>
</li>
<li><p>2和6：其他答主已经说得很好了，其实都需要调用方自己把数据在内核和用户空间里搬来搬去，其实都是同步接口，除非是IOCP这样的专门的异步传输接口，所以这一级其实是同步的，阻塞与非阻塞的区别其实是影响调用接口的结果（在特定条件下是否提前返回结果），而不是调用方式。</p>
</li>
<li><p>3和5：内核一般通过缓冲区，使用DMI来传输数据，所以这一步又是异步的。</p>
</li>
<li><p>4：以太网是个同步时序逻辑，随信号传输时钟，必须两边设备同时就绪了才能开始传输数据，这又是同步的。</p>
</li>
</ul>
<p>总结来说，讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。其他答主说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在2中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。</p>
<p>编程的时候我们写业务代码，基本就是把IO多路复用（事件注册）认为是异步非阻塞的，虽然在linux接口层次还是同步阻塞的。</p>
<p>参考文章：<a href="https://www.zhihu.com/question/19732473/answer/117012135" target="_blank" rel="noopener">https://www.zhihu.com/question/19732473/answer/117012135</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JAVA的==和equals</title>
    <url>/2020/05/09/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/%E5%85%B3%E4%BA%8E==%E5%92%8Cequals/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在大部分的封装类中，都重写了Object类的这个方法，所以两者还是会有区别的。</p>
<ul>
<li><p>总的来说，==是一个关系运算符，如果比较的两端都为基本类型，则判断两者的值是否相等,（判断过程中还有不同基本类型的转化，这里不做讨论），如果比较的两端都为引用类型的话，则比较两者所指向对象的地址是否相同；</p>
</li>
<li><p>对于equals方法，首先，能调用这个方法肯定是一个对象，然后，如果这个对象所在的类重写了equals方法，则按照重写的方法进行比较，如果没有，则比较两者所指向对象的地址是否相同。 </p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>java和python的字符字节数问题</title>
    <url>/2019/06/11/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/java%E5%92%8Cpython%E7%9A%84%E5%AD%97%E7%AC%A6%E5%AD%97%E8%8A%82%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul>
<li>Java中的基本类型char的字节数是固定的，2个字节，默认编码是UTF-16</li>
<li>Java中的字符串的字节数则是不固定的，对于英文字符，占1个字节，而对于中文字符的话，就会因为编码方式而改变：<ul>
<li>如GBK编码，中文字符2个字节</li>
<li>如UTF-8编码，中文字符3个字节</li>
</ul>
</li>
<li>查看方式：str1.getBytes(“utf-8”).length</li>
</ul>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><ul>
<li>Python没有基本类型，就是指字符串，原理和java类型，对于英文字符，占1个字节，而对于中文字符的话，就会因为编码方式而改变。</li>
<li>查看方式：len(str1.encode(‘gbk’))</li>
</ul>
<h4 id="编码转化"><a href="#编码转化" class="headerlink" title="编码转化"></a>编码转化</h4><p>java中char的默认编码是UTF-16，2个字节，但实际操作系统中的默认编码一般都是UTF-8，所以在程序中如果没有指定操作系统的编码，一般都会进行UTF-16到UTF-8的编译码转换。当char的字节范围超过2个字节时，java会通过utf-16 pair的形式来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       String s = <span class="string">"ｮA"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] utf8 = s.getBytes(<span class="string">"utf-8"</span>);<span class="comment">//不指定的话就默认是OS的编码，一般UTF-8</span></span><br><span class="line">            System.out.println(utf8.length);</span><br><span class="line"><span class="comment">//            System.out.println(s.getBytes("utf-16")[0]);</span></span><br><span class="line"><span class="comment">//            System.out.println(s.getBytes("utf-16")[1]);</span></span><br><span class="line"><span class="comment">//            System.out.println(s.getBytes("utf-16")[2]);</span></span><br><span class="line"><span class="comment">//            System.out.println(s.getBytes("utf-16")[3]);</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; utf8.length; i++) &#123;</span><br><span class="line">                System.out.println(byteToBit(utf8[i]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] utf16 = s.getBytes(<span class="string">"utf-16"</span>);</span><br><span class="line">            System.out.println(utf16.length);</span><br><span class="line"><span class="comment">//            System.out.println(s.getBytes("utf-16")[0]);</span></span><br><span class="line"><span class="comment">//            System.out.println(s.getBytes("utf-16")[1]);</span></span><br><span class="line"><span class="comment">//            System.out.println(s.getBytes("utf-16")[2]);</span></span><br><span class="line"><span class="comment">//            System.out.println(s.getBytes("utf-16")[3]);</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; utf16.length; i++) &#123;</span><br><span class="line">                System.out.println(byteToBit(utf16[i]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 //UTF-8的话，第一个字符3个字节，第二个字符1个字节(ACSII码)</span><br><span class="line">11101111</span><br><span class="line">10111101</span><br><span class="line">10101110</span><br><span class="line">01000001</span><br><span class="line">6 //UTF-16的话，第一个字符4个字节，FEFF,FF6E pair，第二个字符2个字节(空字节+ASCII码)</span><br><span class="line">11111110</span><br><span class="line">11111111</span><br><span class="line">11111111</span><br><span class="line">01101110</span><br><span class="line">00000000</span><br><span class="line">01000001</span><br></pre></td></tr></table></figure>
<p>对于byte和char：</p>
<p>byte就是1个字节，8位，int表示-128~127</p>
<p>char的话就是对应byte的编码表示，指定编码集后就对应char，一般不指定进行转换的话就是OS默认utf-8，char直接赋值的话存储的就是java默认utf-16</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA堆和栈内存</title>
    <url>/2020/01/07/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/%E5%A0%86%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java把内存分成两种，一种叫做栈内存，一种叫做堆内存：</p>
<ul>
<li><p>在函数中定义的<strong>一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配</strong></p>
</li>
<li><p>堆内存用于存放由new创建的对象和数组</p>
</li>
</ul>
<p><strong>栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</strong></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>序列化与反序列化</title>
    <url>/2020/03/07/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本概率"><a href="#基本概率" class="headerlink" title="基本概率"></a>基本概率</h2><p>为了磁盘or网络传输，序列/反序列化对象的状态(成员变量)，反序列化的其实是一个新的对象。</p>
<h2 id="java序列化与反序列化"><a href="#java序列化与反序列化" class="headerlink" title="java序列化与反序列化"></a>java序列化与反序列化</h2><p>支持序列化和反序列化的基本类型有：String，Array，Enum和Serializable</p>
<ol>
<li>当父类继承Serializable接口，所有子类都可以被序列化</li>
<li>子类实现了Serializable接口，父类没有，父类中的属性不能序列化（不报错，数据会丢失），但是子类中属性人能正确序列化</li>
<li>如果序列化的属性是对象，这个对象也必须实现Serializable接口，否则会报错</li>
<li>在反序列化时，如果对象的属性有修改或删减，修改的部分属性会丢失，但不会报错</li>
<li>在反序列化时，如果serialVersionUID被修改，那么反序列化时会失败</li>
<li>List或者Map容器中包含的泛型类型也必须实现Serializable接口，否则也会报java.io.NotSerializableException</li>
</ol>
<p>参考：<br><a href="https://blog.csdn.net/moudaen/article/details/19122233" target="_blank" rel="noopener">https://blog.csdn.net/moudaen/article/details/19122233</a><br><a href="https://blog.csdn.net/qq_16628781/article/details/70049623" target="_blank" rel="noopener">https://blog.csdn.net/qq_16628781/article/details/70049623</a></p>
<h2 id="序列化-反序列化协议"><a href="#序列化-反序列化协议" class="headerlink" title="序列化/反序列化协议"></a>序列化/反序列化协议</h2><p>java序列化为二进制码，python的pickle也是序列化模块，为了能够支持<strong>不同平台、不同语言(前后端)之间</strong>的对象传输，必须有相关的通用协议规范。</p>
<p>相关协议有：protobuf、json、xml、thrift等。现在主流是json、protobuf用的比较多，thrift其实是一个rpc框架，也包括了序列化/反序列化协议。</p>
<p>目前网络传输主流框架：</p>
<ul>
<li>Restful框架：用http协议，get/post/put/delte/head，把任何操作都定义成增删改查。序列化/反序列化协议一般是json。主流对公网站一般都是该框架。</li>
<li>RPC框架：只给接口，操作更符合我们日常的编程方法or函数，传输吞吐更快，一般对内网站都用该框架。如dubbo,thrift等。</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA异常处理</title>
    <url>/2020/05/08/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="两种异常类型"><a href="#两种异常类型" class="headerlink" title="两种异常类型"></a>两种异常类型</h2><ul>
<li><p>受检异常：例如IOException，编译器会进行检测，必须捕获或者duck处理，一般是外部因素造成的</p>
</li>
<li><p>非受检异常：RuntimeException及其子类，不要求捕获或者抛出处理，编译器不检测，一般是程序员逻辑漏洞造成的。这个也是我们平时写代码时要注意的异常处理。声明/不声明都无所谓，运行的时候如果出错，异常就会出现。</p>
</li>
</ul>
<p>单线程main这种，如果异常抛出，程序中断。</p>
<p>像web容器这种，出现runtime异常，该线程中断，容器会重新启一个线程，所以其实不影响。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>输入输出流相关类</title>
    <url>/2020/03/14/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9B%B8%E5%85%B3%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="字节流-byte"><a href="#字节流-byte" class="headerlink" title="字节流-byte"></a>字节流-byte</h2><p>基类：InputStream/OutputStream</p>
<p>以输入为例：<br>-System.in: read(), 一个一个字节从控制台读取，因为只有一个字节，所以中文字符读取不了(UTF-16是2个字节)。<br>- FileInputStream：read(), 一个一个字节从磁盘读取<br>- BufferedInputStream:read(), 虽然也是一个一个字节读取，但是是从缓存里读，减少了IO次数，效率更高，所以一般都用这个类包一层<br>- DataInputStream:readInt(), readDouble()等，直接写入各种数据类型，底层也是通过字节传输。要与DataOutputStream配合使用。<br>- ObjectInputStream: readObject(),直接写入对象，同理。</p>
<h2 id="字符流-char"><a href="#字符流-char" class="headerlink" title="字符流-char"></a>字符流-char</h2><p>基类：Reader/Writer</p>
<p>以输入为例：<br>- InputStreamReader: read(),一个一个字符读取<br>- FileReader：read(), 一个一个字符从磁盘读取<br>- BufferedReader:readLine(), 直接读取一行字符，从缓存里读减少了IO次数，效率更高，所以一般都用这个类包一层<br>- 没有DataInputStreamReader，因为数据本身就是若干个字符了<br>- 没有ObjectInputStreamReader，同理</p>
<h2 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h2><ul>
<li>网络一般要靠字节传输，但是数据往往通过字符承载。所以要将字节流转成字符流。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BufferedReader(new InputStreamReader(new InputStream(...)))</span><br></pre></td></tr></table></figure>
<ul>
<li>直接传数据：<br><code>DataInputStream(new BufferedInputStream(new InputStream(...)))</code></li>
<li>直接传对象：<br><code>ObjectInputStream(new BufferedInputStream(new InputStream(...)))</code></li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>import及__init__.py</title>
    <url>/2019/03/07/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Python/import%E5%8F%8A__init__.py/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="import注意事项"><a href="#import注意事项" class="headerlink" title="import注意事项:"></a>import注意事项:</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> package1 <span class="keyword">import</span> module1</span><br><span class="line"><span class="keyword">from</span> package1.module2 <span class="keyword">import</span> function1</span><br><span class="line"><span class="keyword">from</span> package2 <span class="keyword">import</span> class1</span><br><span class="line"><span class="keyword">from</span> package2.subpackage1.module5 <span class="keyword">import</span> function2</span><br></pre></td></tr></table></figure>
<p>注意，module.function这种形式是不行的，用.前面只能是package</p>
<h2 id="init-py注意事项"><a href="#init-py注意事项" class="headerlink" title="init.py注意事项:"></a><strong>init</strong>.py注意事项:</h2><ul>
<li><p>放在package目录下</p>
</li>
<li><p>可以没有，这种情况下一定要手动 from package import module</p>
</li>
<li><p>如果有，import package的时候，会自动加载该文件的内容，其中用法有包括:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">'foofactories'</span>, <span class="string">'tallFoos'</span>, <span class="string">'shortfoos'</span>, <span class="string">'medumfoos'</span>,</span><br><span class="line">           <span class="string">'santaslittlehelperfoo'</span>, <span class="string">'superawsomefoo'</span>, <span class="string">'anotherfoo'</span>]</span><br><span class="line"><span class="comment"># deprecated to keep older scripts who import this from breaking</span></span><br><span class="line"><span class="keyword">from</span> foo.foofactories <span class="keyword">import</span> fooFactory</span><br><span class="line"><span class="keyword">from</span> foo.tallfoos <span class="keyword">import</span> tallFoo</span><br><span class="line"><span class="keyword">from</span> foo.shortfoos <span class="keyword">import</span> shortFoo</span><br></pre></td></tr></table></figure>
<p>从而达到 from package import function的目的</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Texlive和Ctex的中文兼容问题</title>
    <url>/2017/07/07/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Latex/some-questions-about-ctex-and-texlive/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为用的Ubuntu，所以用的是texlive编译环境来写latex,当然我也用过ctex套装。总体来讲，感觉编译速度texlive要更胜一筹，用起来更加舒服。</p>
<p>今早师妹找我要beamer的模板，因为师妹用的是windows系统下的ctex，所以就发现了一个以前没弄清楚的问题，关于ctex和texlive的兼容问题。</p>
<h1 id="概念区别"><a href="#概念区别" class="headerlink" title="概念区别"></a>概念区别</h1><p>说兼容问题之前，关于ctex和texlive有一些基本概念要搞清楚（我之前也弄混了。。）<br><a id="more"></a></p>
<ul>
<li>Texlive是一个latex语言的编译环境， Ctex只是一个中文版套装！</li>
<li>Latex的编译环境主要有以下几个：<ul>
<li>Texlive(主要用于Linux)</li>
<li>MikTex(主要用于Windows)</li>
<li>MaxTex(主要用于Mac)</li>
</ul>
</li>
<li>Ctex是专门针对中文的国人整理的一个套装，用的是MikTex的编译环境，还包含了WinEdt编辑器，GsView等软件。</li>
<li>Ctex package又是另一个概念！在我们需要写中文latex文档时，就需要用到ctex这个宏包，所以此ctex又非彼ctex。。</li>
</ul>
<h1 id="英文兼容"><a href="#英文兼容" class="headerlink" title="英文兼容"></a>英文兼容</h1><p>Texlive和ctex在英文上面，没有任何的兼容问题。我以前在这两种环境下切换时，都是写的英文文档，这就是为什么我之前一直觉得没有兼容问题，天真地以为两者虽然环境不同，但latex,pdflatex,xelatex等等命令功能都是一样的。。但事实上，之所以英文没有兼容问题，是因为无论那种编码方式，英文都是以一个字节的ASCII码形式编码，因此在任何编码中，英文都是兼容的。</p>
<h1 id="中文兼容"><a href="#中文兼容" class="headerlink" title="中文兼容"></a>中文兼容</h1><p>中文兼容就是一个很大的问题了，因为在ctex的winedt编辑器中，默认的编码方式是GBK，而在linux环境下，默认的编码方式是utf-8，这就是为什么很多时候，linux下的文件放到windows下中文就会乱码。</p>
<p>对于编辑器而言，我们可以设置不同的编码打开方式，让文件正常显示，但是尽管如此，文件本身的编码方式依然是不会改变的！所以最好的方法，就是在哪种环境下，就转换为哪种环境下的编码方式，以防止后面莫名奇妙地出错。注意，这里就要提到一个叫做inputenc的包了, 这个包可以让我们选择打开文件的编码方式，但是我对于gbk编码的文件选择utf-8打开，最终还是会出现问题。。所以我觉得这个包应该也是没有编码转换的功能，还是之前那个方法，最好先将文件编码转换好！</p>
<p>既然文件编码已经转换好，接下来说一说，ctex和texlive对中文支持的区别</p>
<h2 id="Texlive中文支持"><a href="#Texlive中文支持" class="headerlink" title="Texlive中文支持"></a>Texlive中文支持</h2><p>Texlive下要支持中文，最简单的方法就是满足下面三个条件</p>
<ul>
<li>UTF-8编码的tex文件</li>
<li><code>\usepackage{ctex}</code></li>
<li>Xelatex编译文件</li>
</ul>
<p>简单明了，这也是一个通用的方法，在任何编译环境下，都可以使用此方法支持中文。注意，有的时候在用这个方法编译从ctex那边移植过来的文件时，可能会遇到中文字体问题，大概率是因为模板里用了windows下的字体，而linux下没有这些字体，需要安装。</p>
<h2 id="Ctex中文支持"><a href="#Ctex中文支持" class="headerlink" title="Ctex中文支持"></a>Ctex中文支持</h2><p>除了上面所述的方法，ctex有自己独特的中文支持方法（毕竟国人开发）：</p>
<ul>
<li>GBK编码的tex文件</li>
<li><code>\usepackage{ctex}</code></li>
<li>latex-dvi-ps-pdf或者pdflatex编译文件</li>
</ul>
<p>这个方法也挺简单的，但是只能针对于ctex,我觉得其中的原理应该是ctex对于pdflatex和latex命令做了一些调整，使其能够支持中文，我觉得他们本身应该是不能支持中文的。</p>
<p><strong>切记，这两种方式最好不要随意搭配，搭配后可能会成功，但大概率是要出问题的。。我觉得最好的办法就是采用xelatex编辑utf-8文件！</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上这些是我经过查阅资料以及在windows和ubuntu下试验总体得到的，具体一些理解可能会有偏差，但以上几个方法是肯定正确的。</p>
<p>最后加一个小tips：<br>如果要改变beamer模板中的itemsize符号，需要加<code>\setbeamertemplate{items}[符号]</code>;若是article环境，需加<code>\renewcommand{\labelitemi}{符号}</code>。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Latex</category>
      </categories>
  </entry>
  <entry>
    <title>下划线用法</title>
    <url>/2020/10/09/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Python/%E4%B8%8B%E5%88%92%E7%BA%BF%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjj8geqjr5j31700mo7gr.jpg" alt="image-20201009175708340"></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>python2和3切换注意事项</title>
    <url>/2019/02/02/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Python/python2%E5%92%8C3%E5%88%87%E6%8D%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>除法问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>/<span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>/<span class="number">2.0</span></span><br><span class="line"><span class="number">1.5</span></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>/<span class="number">2</span></span><br><span class="line"><span class="number">1.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>//<span class="number">2</span></span><br><span class="line"><span class="number">1.5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  <strong>解决方法</strong>：from <strong>future</strong> import division</p>
<ul>
<li><p>字符串编码不同：</p>
<ul>
<li><p>python2字符串分为str类型和unicode类型</p>
<ul>
<li>str：非unicode形式，以各种编码方式用字节存储(gbk, ascii, utf-8, utf-16等)</li>
<li>Unicode：unicode形式</li>
</ul>
<p>默认就是str类型，除非指定u”字符串”，才是unicode类型。相对来说不合理，在代码中涉及到中文的时候(用str类型)就会遇到编码和解码问题，中间有各种隐式的转换，程序可能报错，因为python2的默认编码为ascii，sys.getdefaultencoding()</p>
</li>
<li><p>pyhont3字符串分为str类型和bytes类型</p>
<ul>
<li>str：unicode形式</li>
<li>bytes：非unicode形式，以各种编码方式用字节存储(gbk, ascii, utf-8, utf-16等)</li>
</ul>
<p>这样更加合理一点，我们平时用到的就是str类型，用最通用的Unicode来表示，只在底层存储时候转成相应编码方式。</p>
</li>
</ul>
<p><strong>解决方法</strong>：文件头部指定编码utf-8，sys.setdefaultencoding为utf-8。</p>
</li>
<li><p>map,filter等。python2返回结果是list，python3返回一个可迭代对象，需要list()才行</p>
</li>
<li><p>python3没有xrange</p>
</li>
<li><p>python2的raw_input() 等同于 python3的input()， python2的input()只接受数字输入</p>
</li>
<li><p>print。 python2中的print是语句，python3是函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># py2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">(<span class="string">'hello'</span>, <span class="string">'world'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong>: from <strong>future</strong> import print_function</p>
</li>
<li><p>还有个我自己发现的列表解析式的问题！ </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    y = [j <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    print(j)</span><br></pre></td></tr></table></figure>
<p>这个代码，python2下 j = 9，但python3下j不存在！说明j的作用域只在列表解析式里。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>关于python2的编码问题</title>
    <url>/2020/10/22/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Python/%E5%85%B3%E4%BA%8Epython2%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>首先我们要弄明白Unicode这个概念，我以前一直理解有问题，以为是类似于ascii、utf-8的一种编码方式而已，然而我错了，可以看这篇文章：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a>，总结一下就是：</p>
<ul>
<li>Unicode不是一种编码方式，而是定义了统一的字符集，包含了世界上的所有字符。它相当于维护了一个映射code point，一个二进制表示对应一个字符。虽然从这个理解上，也有点像是编码，毕竟也要用一个大概四个字节的二进制表示来表示一个字符，但还是要认为他只是一个字符集，而不是编码方式。</li>
<li>UTF-8则是Unicode具体的一种编码实现方式，采用变长的字节来存储每个字符。</li>
<li>任何字符都可以用unicode表示，然后用某种编码方式，例如utf-8、ascii、gbk等方式，存储为字节形式。</li>
</ul>
<h2 id="Python中的编码问题"><a href="#Python中的编码问题" class="headerlink" title="Python中的编码问题"></a>Python中的编码问题</h2><ul>
<li>在python2里面，str类型是以某种编码方式存好的字节，unicode类型才是以无编码方式存储的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo = <span class="string">'人'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\xe4\xba\xba'</span>  <span class="comment"># 3个字节</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo = <span class="string">u'人'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'\u4eba'</span> <span class="comment"># 1个中文字符, 2个字节</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>为了避免一系列蛋疼的编码问题，我们可以采用这种方式：</p>
<ul>
<li><p>文件头部指定默认编码方式，这样str类型默认是按照utf-8来编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定python解释器的默认编码方式，这样中间有一些隐式的编解码转换，就不会出现蛋疼的问题了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>很好的几个资料：<a href="https://www.cnblogs.com/zh605929205/articles/7268840.html" target="_blank" rel="noopener">Byte(字节) 与 Bytearray(二进制数组)</a>, <a href="https://hexilee.me/2018/09/21/coding/" target="_blank" rel="noopener">编码：字符串和二进制</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>切片操作</title>
    <url>/2018/06/03/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Python/%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="python切片"><a href="#python切片" class="headerlink" title="python切片"></a>python切片</h2><p>切片复制属于较深拷贝，意思是如果拷贝的元素是可变对象，那么指的是同一段内存。如a = [1,2,3, [1,2,3]]中的a[3]，跟copy()方法一样，深拷贝是deepcopy()。</p>
<h2 id="go切片"><a href="#go切片" class="headerlink" title="go切片"></a>go切片</h2><p>切片属于一段引用，即深拷贝，切片有长度和容量之分。切片中[:]尾数默认是长度，但是容量是指原来数组的长度,如果切片长度超出，容量还在的话，可以正常访问。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>引用，浅拷贝和深拷贝</title>
    <url>/2019/05/06/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Python/%E5%BC%95%E7%94%A8,%20%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>变量名是别名，没有开辟新的内存，指向同一块内存</p>
<h3 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h3><p>一般出现在array-like对象中，如list等。</p>
<p>虽然开辟了一块新的内存，但是对象中的每一个元素都是指向原对象的每个元素的地址。例如：</p>
<p>a = [1,2,[1,2,3]]</p>
<p>b =copy.copy(a)</p>
<p>id(a[2]) == id(b[2])</p>
<p>对于元素为不可变对象时，倒无所谓，如果元素为可变对象，那么a变b也变。</p>
<p>切片就是浅拷贝！！</p>
<h3 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h3><p>既开辟了新的内存，对象中的每个元素又都是数值的拷贝，而非地址。</p>
<p>使用方式：copy.deepcopy()</p>
<h2 id="神奇的pandas"><a href="#神奇的pandas" class="headerlink" title="神奇的pandas:"></a>神奇的pandas:</h2><p>﻿经过对pandas的一番探索，引用，切片，花式索引。。结论是：pandas的内存机制实在是有点复杂，真是摸不透。</p>
<p>例如：a是一个dataframe, b = a.loc[:]，这个操作后a.loc[1]的地址都会变..太恐怖了</p>
<p>所以还是总结一下，平时用的比较多的操作：</p>
<p>对于切片处理，如b = a.loc[:]，如果修改b.loc[<em>,</em>]的值，a也会变，如果b经过一些其他的操作，如sort_values等之后，b又变成了一个单独的内存空间。</p>
<p>对于花式索引，如b = a[a[‘<em>‘] &gt; </em>]，修改b.loc[<em>,</em>]的值，a不会变。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Linux Shell多进程并发以及并发数控制</title>
    <url>/2018/11/05/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Shell/Shell%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E4%BB%A5%E5%8F%8A%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>利用命名管道：和文件描述符绑定，利用FIFO，数据滞留的特性，控制并发数。</p>
<p><a href="https://blog.csdn.net/yeweiouyang/article/details/52512522" target="_blank" rel="noopener">https://blog.csdn.net/yeweiouyang/article/details/52512522</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>shell交互式及登录式</title>
    <url>/2019/02/15/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Shell/shell%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%8F%8A%E7%99%BB%E5%BD%95%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>登录式和非登录式区别：</p>
<p>“登陆shell”通常指的是：（/etc/profile,~/.bash_profile, ~/.bashrc,/etc/bashrc）</p>
<ul>
<li><p>用户通过输入用户名/密码（或证书认证）后启动的shell；</p>
</li>
<li><p>通过带有-l|—login参数的bash命令启动的shell。</p>
</li>
</ul>
<p>例如，系统启动、远程登录、使用su -切换用户、通过bash —login命令或 -i 启动bash等。</p>
<p>而其他情况启动的shell基本上就都是“非登陆shell”了。(~/.bashrc, /etc/bashrc)</p>
<p>例如，从图形界面启动终端、使用su切换用户、通过bash命令启动bash等。 </p>
<p>“登录shell”和“非登陆shell”的区别在于<strong>启动shell时所执行的startup文件不同</strong>。</p>
<p>交互式和非交互式区别：</p>
<p>非交互式：有-c选项或者执行一个shell脚本</p>
<p>交互式： 命令行交互形式</p>
<p>注意：非交互式shell应用基本都是原shell环境下创建一个非交互式子shell执行程序，用户不变，环境变量不变，不会重新加载startup文件。</p>
<p>总结：</p>
<p>日常用到的就这三类：</p>
<p>交互式登录shell</p>
<p>交互式非登录shell</p>
<p>非交互式shell</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>shell中的$1,$#等</title>
    <url>/2018/11/11/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Shell/shell%20$1,$#%E7%AD%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id><a href="#" class="headerlink" title="$$"></a>$$</h3><p>Shell本身的PID（ProcessID）</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="$!"></a>$!</h3><p>Shell最后运行的后台Process的PID</p>
<h3 id="-2"><a href="#-2" class="headerlink" title="$?"></a>$?</h3><p>最后运行的命令的结束代码（返回值）</p>
<h3 id="-3"><a href="#-3" class="headerlink" title="$-"></a>$-</h3><p>使用Set命令设定的Flag一览</p>
<h3 id="-4"><a href="#-4" class="headerlink" title="$*"></a>$*</h3><p>所有参数列表。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</p>
<h3 id="-5"><a href="#-5" class="headerlink" title="$@"></a>$@</h3><p>所有参数列表。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<h3 id="-6"><a href="#-6" class="headerlink" title="$"></a>$</h3><p>添加到Shell的参数个数</p>
<h3 id="0"><a href="#0" class="headerlink" title="$0"></a>$0</h3><p>Shell本身的文件名</p>
<h3 id="1～-n"><a href="#1～-n" class="headerlink" title="$1～$n"></a>$1～$n</h3><p>添加到Shell的各参数值。$1是第1参数、$2是第2参数…。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>类变量和实例变量</title>
    <url>/2021/06/25/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Python/%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>类和实例都可以访问 类变量，但是实例只能访问，无法修改，一旦修改了，则会生成一个同名的实例变量，而非本身的类变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A(object):</span><br><span class="line">    a = 1</span><br><span class="line">    b = 2</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print self.a  # 1</span><br><span class="line">        self.a = 3</span><br><span class="line"></span><br><span class="line">t = A()</span><br><span class="line">print t.a  # 3</span><br><span class="line">print A.a  # 1</span><br><span class="line"></span><br><span class="line">t.a = 4</span><br><span class="line">print t.a  # 4 </span><br><span class="line">print A.a  # 1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>shell变量中的反斜杠</title>
    <url>/2018/05/22/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Shell/shell%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>变量最好用双引号引起来，可以解析里面的变量和命令</p>
</li>
<li><p>用单引号引起来的变量是硬转义</p>
</li>
<li>echo -E “” 无转义，echo -e “”有转义</li>
<li>对于\，在命令行本身就代表了换行继续的意思，多以无论-E 还 -e，\本身就自带转义。</li>
</ul>
<p>因此，对于多个\先要默认对多个\转义，并且转义时按照两两消除的方式，然后再按命令参数执行命令。</p>
<p>例如，</p>
<p>“\...\“，假设为x个\，若x为偶数，则解析为x/2个\，若x为奇数，则最后一个\生效，另起换行。</p>
<p>此时，如果再执行echo -e，也就是再次转义，那么就是在之前的基础上，再次两两消除转义。</p>
<p>举例：</p>
<p>echo -e “\\\”  : 换行继续</p>
<p>echo  -E “\\n” : \n</p>
<p>echo -e “\\n”  : \n</p>
<p>echo -e “\\\n” : \ 换行</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>shell的变量</title>
    <url>/2019/07/02/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Shell/shell%E7%9A%84%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>只在函数内定义的变量，如果不加local关键词，其实还是一个全局变量(函数外能够访问)</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在当前shell内定义的变量，其他shell不能访问</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>用export定义，在当前shell的子shell中可以传递，传子不传父。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>sudo与su</title>
    <url>/2019/02/15/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Shell/sudo%E4%B8%8Esu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>sudo -u user单纯以某用户身份运行命令，并不切换环境，需要输入当前用户密码，。sudo的各类权限在/etc/sudoers配置</p>
<p>su 则切换到某用户的环境下，需要输入某用户的密码。这里注意一定要加 su -  ，只有这样才会生成login shell加载/etc/profile和~/.bash_profile，如果不加的话，启动non-login shell，不加载上述文件，环境变量部分是原用户的。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>关于nuhup与&amp;</title>
    <url>/2018/11/02/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Shell/%E5%85%B3%E4%BA%8Enuhup%E4%B8%8E&amp;/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.jianshu.com/p/747e0d5021a2" target="_blank" rel="noopener">https://www.jianshu.com/p/747e0d5021a2</a></p>
<ul>
<li><p>如果后台&amp;开了多个子进程，关闭父进程，子进程变成孤儿进程，继续运行。</p>
</li>
<li><p>如果后台&amp;开了多个子进程，关闭终端，进程全部结束。</p>
</li>
<li><p>如果后台&amp;开了多个字进程，但是用了nohup，关闭终端，子进程继续运行。</p>
</li>
<li><p>如果后台&amp;开了多个子进程，先关闭父进程，再关闭终端，子进程继续运行，子进程变成孤儿进程，父进程变了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>关于sh,source,exec</title>
    <url>/2018/11/02/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Shell/%E5%85%B3%E4%BA%8Esh,source,exec/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>source相当于把文件中的命令按顺序在当前shell执行一次</p>
<p>sh则会另起一个子shell，export的环境变量不能返回到父shell</p>
<p><a href="https://www.jianshu.com/p/dd7956aec097" target="_blank" rel="noopener">https://www.jianshu.com/p/dd7956aec097</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>父子shell和父子进程</title>
    <url>/2019/02/15/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Shell/%E7%88%B6%E5%AD%90shell%E5%92%8C%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先，shell也是一个进程！</p>
<p>举个例子：</p>
<p>在某个shell下(该shell也是一个进程，id为1)，执行一个脚本文件，同时便会生成一个非交互子shell（进程id为2），然后该脚本文件的每一行可执行程序，又会生成新的子进程id如3，4，5，6等等</p>
<p>父子shell中的变量问题：</p>
<ul>
<li><p>普通自定义变量不会共享，只在当前shell生效</p>
</li>
<li><p>环境变量：</p>
<p> 如果没有切换用户，子shell（非交互式）共享父shell的环境变量</p>
<p> 如果切换了用户:</p>
<ul>
<li><p>假设是su，那会创建子non-login shell（交互式），环境变量部分新用户，部分原用户，部分消失(只加载~/.bashrc)</p>
</li>
<li><p>假设是su -，那会创建login shell（交互式），环境变量全部为新用户(加载/etc/profile,~/.bash_profile)</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>Vim自动补全神器-YouCompleteMe</title>
    <url>/2017/06/12/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Vim/Vim%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p>Ubuntu自带的vim是vim.tiny版本，很多功能都不全，所以我们需要装一个完整版的，并且我习惯装一个gvim,<code>sudo apt-get install vim-gtk</code>。 有意思的是，我发现<code>apt-get</code>下面有一个叫<code>vim+youcompleteme</code>的版本，我就好奇得装了一下，结果打开vim发现并没有补全功能，但是却装了<code>ruby，nodejs,ycmd</code>等几个软件，<code>ycmd</code>应该就是补全软件，然而不知道该怎么在vim里使用…所以最终我还是按照github上的说明手动装了<code>youcompleteme</code>,这部分留到后文说。</p>
<a id="more"></a>
<h2 id="插件Vundle"><a href="#插件Vundle" class="headerlink" title="插件Vundle"></a>插件Vundle</h2><p>Vundle是一个很实用的vim插件，通过它可以方便得管理其他插件，安装很简单。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure></p>
<p>装完之后，需要在<code>.vimrc</code>里进行配置，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set nocompatible              &quot; be iMproved, required</span><br><span class="line">filetype off                  &quot; required</span><br><span class="line"></span><br><span class="line">&quot; set the runtime path to include Vundle and initialize</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; alternatively, pass a path where Vundle should install plugins</span><br><span class="line">&quot;call vundle#begin(&apos;~/some/path/here&apos;)</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle, required</span><br><span class="line">Plugin &apos;VundleVim/Vundle.vim&apos;</span><br><span class="line"></span><br><span class="line">&quot; The following are examples of different formats supported.</span><br><span class="line">&quot; Keep Plugin commands between vundle#begin/end.</span><br><span class="line">&quot; plugin on GitHub repo</span><br><span class="line">Plugin &apos;tpope/vim-fugitive&apos;</span><br><span class="line">&quot; plugin from http://vim-scripts.org/vim/scripts.html</span><br><span class="line">&quot; Plugin &apos;L9&apos;</span><br><span class="line">&quot; Git plugin not hosted on GitHub</span><br><span class="line">Plugin &apos;git://git.wincent.com/command-t.git&apos;</span><br><span class="line">&quot; git repos on your local machine (i.e. when working on your own plugin)</span><br><span class="line">Plugin &apos;file:///home/gmarik/path/to/plugin&apos;</span><br><span class="line">&quot; The sparkup vim script is in a subdirectory of this repo called vim.</span><br><span class="line">&quot; Pass the path to set the runtimepath properly.</span><br><span class="line">Plugin &apos;rstacruz/sparkup&apos;, &#123;&apos;rtp&apos;: &apos;vim/&apos;&#125;</span><br><span class="line">&quot; Install L9 and avoid a Naming conflict if you&apos;ve already installed a</span><br><span class="line">&quot; different version somewhere else.</span><br><span class="line">&quot; Plugin &apos;ascenator/L9&apos;, &#123;&apos;name&apos;: &apos;newL9&apos;&#125;</span><br><span class="line"></span><br><span class="line">&quot; All of your Plugins must be added before the following line</span><br><span class="line">call vundle#end()            &quot; required</span><br><span class="line">filetype plugin indent on    &quot; required</span><br><span class="line">&quot; To ignore plugin indent changes, instead use:</span><br><span class="line">&quot;filetype plugin on</span><br><span class="line">&quot;</span><br><span class="line">&quot; Brief help</span><br><span class="line">&quot; :PluginList       - lists configured plugins</span><br><span class="line">&quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span><br><span class="line">&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache</span><br><span class="line">&quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span><br><span class="line">&quot;</span><br><span class="line">&quot; see :h vundle for more details or wiki for FAQ</span><br><span class="line">&quot; Put your non-Plugin stuff after this line</span><br></pre></td></tr></table></figure></p>
<p>最终打开vim，输入<code>：PluginInstall</code>来安装你在配置文件里写的插件。</p>
<p>我安装了下面几个我常用的插件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot; My Plugin here:</span><br><span class="line"></span><br><span class="line">&quot; plugin on GitHub repo</span><br><span class="line">Plugin &apos;Valloric/YouCompleteMe&apos;</span><br><span class="line">Plugin &apos;luochen1990/rainbow&apos;</span><br><span class="line">Plugin &apos;fholgado/minibufexpl.vim&apos;</span><br><span class="line">Plugin &apos;scrooloose/nerdtree&apos;</span><br></pre></td></tr></table></figure></p>
<h1 id="YouCompleteMe"><a href="#YouCompleteMe" class="headerlink" title="YouCompleteMe"></a>YouCompleteMe</h1><p>在我的插件里可以看到我装了YouCompleteMe这个插件，但是光vundle装好还是不够的，我们需要再编译一个能用的引擎。</p>
<h2 id="安装必备的编译环境和python环境"><a href="#安装必备的编译环境和python环境" class="headerlink" title="安装必备的编译环境和python环境"></a>安装必备的编译环境和python环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential cmake</span><br><span class="line">sudo apt-get install python-dev python3-dev</span><br></pre></td></tr></table></figure>
<h2 id="检查vim版本"><a href="#检查vim版本" class="headerlink" title="检查vim版本"></a>检查vim版本</h2><p>我们需要检查vim版本以及vim支持的python版本，保证vim版本高于7.4.1578,支持python2或者Python3。我们可以输入命令：<code>vim --version</code>来查看，以下是我的输出截图：<br><img src="http://upload-images.jianshu.io/upload_images/825093-cc5dac3d1fd71ef2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="image.png"><br>可以看到版本是7.4.1689，不支持python2,但支持python3（貌似Ubuntu16.04开始移除python2的支持了）。</p>
<h2 id="编译支持C家族语义补全的YCM"><a href="#编译支持C家族语义补全的YCM" class="headerlink" title="编译支持C家族语义补全的YCM"></a>编译支持C家族语义补全的YCM</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/bundle/YouCompleteMe</span><br><span class="line">Python3 ./install.py --clang-completer //由于我的vim只支持Python3,所以在前面加python3命令</span><br></pre></td></tr></table></figure>
<p>命令执行之后，系统会去下载libclang,因为YCM语义支持是靠clang编译器的，这里需要经过漫长得等待。。如果一切顺利的话，YCM就安装完毕了。</p>
<h2 id="YCM配置"><a href="#YCM配置" class="headerlink" title="YCM配置"></a>YCM配置</h2><p>我的YCM配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;YouCompleteMe</span><br><span class="line">&quot;let g:ycm_path_to_python_interpreter = &apos;/usr/bin/python&apos;</span><br><span class="line">set runtimepath+=~/.vim/bundle/YouCompleteMe</span><br><span class="line">let g:ycm_collect_identifiers_from_tags_files = 1           &quot; 开启 YCM 基于标签引擎</span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释与字符串中的内容也用于补全</span><br><span class="line">let g:syntastic_ignore_files=[&quot;.*\.py$&quot;]</span><br><span class="line">let g:ycm_seed_identifiers_with_syntax = 1                  &quot; 语法关键字补全</span><br><span class="line">let g:ycm_complete_in_comments = 1</span><br><span class="line">let g:ycm_confirm_extra_conf = 0</span><br><span class="line">&quot;let g:ycm_key_list_select_completion = [&apos;&lt;c-n&gt;&apos;, &apos;&lt;Down&gt;&apos;]  &quot; 映射按键, 没有这个会拦截掉tab, 导致其他插件的tab不能用.</span><br><span class="line">&quot;let g:ycm_key_list_previous_completion = [&apos;&lt;c-p&gt;&apos;, &apos;&lt;Up&gt;&apos;]</span><br><span class="line">let g:ycm_complete_in_comments = 1                          &quot; 在注释输入中也能补全</span><br><span class="line">let g:ycm_complete_in_strings = 1                           &quot; 在字符串输入中也能补全</span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释和字符串中的文字也会被收入补全</span><br><span class="line">let g:ycm_global_ycm_extra_conf=&apos;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&apos;</span><br><span class="line">&quot;let g:ycm_show_diagnostics_ui = 0                           &quot; 禁用语法检查</span><br><span class="line">inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;CR&gt;&quot; |            &quot; 回车即选中当前项</span><br><span class="line">nnoremap &lt;F5&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line">&quot;let g:ycm_min_num_of_chars_for_completion=2                 &quot; 从第2个键入字符就开始罗列匹配项</span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion = 1  &quot; 补全后自动关闭preview</span><br></pre></td></tr></table></figure></p>
<p>一个能够进行语法检查，自动补全，并且GoToDefinition的YCM就可以使用了，但是还有一点瑕疵：＃include <iostream>, #include <stdio> vector, 什么的都不能补全，这是因为这些头文件的路径没有被找到，下面的工作就是要让YouCompleteMe找到这些头文件，而且，以后有什么库文件，比如OpenCV，OPenGL什么的，都可以按照这个方法添加。</stdio></iostream></p>
<p>打开并编辑~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py，这就是我们设定vim默认调用的YCM配置文件，然后可以在flags[*]数组的后面添加你想要的路径，例如: stdio.h等Ｃ语言的头文件包含在/usr/include中，那么您需要添加这样一条</p>
<blockquote>
<p>‘-isystem’,<br>‘/usr/include’,</p>
</blockquote>
<p>如果需要C++的补全，就需要添加：</p>
<blockquote>
<p>‘-isystem’,<br>‘/usr/include/c++/5’,</p>
</blockquote>
<p>需要什么，就添加什么，现在编辑c/c++文件你就发现支持头文件补全了！</p>
<h1 id="我的vim配置"><a href="#我的vim配置" class="headerlink" title="我的vim配置"></a>我的vim配置</h1><p>根据个人习惯，我的vimrc配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Wei Lyu</span><br><span class="line">&quot;levy_lv@hotmail.com</span><br><span class="line">&quot;levylv.github.io</span><br><span class="line"></span><br><span class="line">&quot;====================&quot;</span><br><span class="line">&quot;        通用        &quot;</span><br><span class="line">&quot;====================&quot;</span><br><span class="line">set nocompatible              &quot; be iMproved, required</span><br><span class="line">filetype plugin indent on</span><br><span class="line">set nobackup &quot;不备份 </span><br><span class="line">set autochdir &quot;自动切换当前目录</span><br><span class="line">set mouse=a</span><br><span class="line"></span><br><span class="line">&quot;启动，语法高亮，配色</span><br><span class="line">winpos 500 200   &quot;窗口位置</span><br><span class="line">set lines=30 columns=85  &quot;窗口大小</span><br><span class="line">set guioptions-=T  &quot;不要菜单栏</span><br><span class="line">set laststatus=2   &quot;总是显示状态栏</span><br><span class="line">set hlsearch  &quot;搜索高亮</span><br><span class="line">set ignorecase &quot;搜索忽略大小写</span><br><span class="line">syntax enable</span><br><span class="line">syntax on</span><br><span class="line">set t_Co=256</span><br><span class="line">set cursorline &quot;高亮光标行</span><br><span class="line">set ruler   &quot;显示光标位置状态栏</span><br><span class="line">set number</span><br><span class="line">set guifont=Ubuntu\ Mono\ 13</span><br><span class="line">colorscheme molokai</span><br><span class="line">set clipboard=unnamed &quot;可以用系统剪贴板</span><br><span class="line"></span><br><span class="line">&quot;Tab相关</span><br><span class="line">set expandtab &quot;制表符扩展为空格</span><br><span class="line">set tabstop=4 &quot;制表符占用空格数</span><br><span class="line">set softtabstop=4 &quot;将连续数量的空格视为一个制表符</span><br><span class="line">set shiftwidth=4 &quot;格式化时制表符占用空格数</span><br><span class="line">set cindent</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line">&quot;编码相关</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set langmenu=zh_CN.UTF-8</span><br><span class="line">language message zh_CN.UTF-8</span><br><span class="line">set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1</span><br><span class="line"></span><br><span class="line">&quot;使用CTRL+[hjkl]在窗口间导航&quot;</span><br><span class="line">map &lt;C-c&gt; &lt;C-W&gt;c</span><br><span class="line">map &lt;C-j&gt; &lt;C-W&gt;j</span><br><span class="line">map &lt;C-k&gt; &lt;C-W&gt;k</span><br><span class="line">map &lt;C-h&gt; &lt;C-W&gt;h</span><br><span class="line">map &lt;C-l&gt; &lt;C-W&gt;l</span><br><span class="line"></span><br><span class="line">&quot;使用箭头导航buffer&quot;</span><br><span class="line">map &lt;right&gt; :bn&lt;cr&gt;</span><br><span class="line">map &lt;left&gt; :bp&lt;cr&gt;</span><br><span class="line">set autowrite &quot;在切换buffer时自动保存当前的文件</span><br><span class="line"></span><br><span class="line">&quot;&quot;使用ALT+[jk]来移动行内容</span><br><span class="line">nmap &lt;M-j&gt; mz:m+&lt;cr&gt;`z</span><br><span class="line">nmap &lt;M-k&gt; mz:m-2&lt;cr&gt;`z</span><br><span class="line">vmap &lt;M-j&gt; :m&apos;&gt;+&lt;cr&gt;`&lt;my`&gt;mzgv`yo`z</span><br><span class="line">vmap &lt;M-k&gt; :m&apos;&lt;-2&lt;cr&gt;`&gt;my`&lt;mzgv`yo`z</span><br><span class="line"></span><br><span class="line">&quot;根据文件类型做不同处理</span><br><span class="line">function HeaderPython()  &quot;python加头注释</span><br><span class="line">    call setline(1, &quot;#!/usr/bin/env python3&quot;)</span><br><span class="line">    call append(1,  &quot;# -*- coding: utf-8 -*-&quot;)</span><br><span class="line">    call append(2,  &quot;# mail:levy_lv@hotmail.com&quot;)</span><br><span class="line">    call append(3,  &quot;# Lyu Wei @ &quot; . strftime(&apos;%Y-%m-%d&apos;, localtime()))</span><br><span class="line">    normal G</span><br><span class="line">    normal o</span><br><span class="line">    normal o</span><br><span class="line">endf</span><br><span class="line">autocmd bufnewfile *.py call HeaderPython()</span><br><span class="line"></span><br><span class="line">function HeaderBash()  &quot;shell脚本加注释</span><br><span class="line">    call setline(1, &quot;#!/bin/bash&quot;)</span><br><span class="line">    call append(1,  &quot;# -*- coding: utf-8 -*-&quot;)</span><br><span class="line">    call append(2,  &quot;# mail:levy_lv@hotmail.com&quot;)</span><br><span class="line">    call append(3,  &quot;# Lyu Wei @ &quot; . strftime(&apos;%Y-%m-%d&apos;, localtime()))</span><br><span class="line">    normal G</span><br><span class="line">    normal o</span><br><span class="line">    normal o</span><br><span class="line">endf</span><br><span class="line">autocmd bufnewfile *.sh call HeaderBash()</span><br><span class="line"></span><br><span class="line">function HeaderCpp() &quot;C++文件加头文件</span><br><span class="line">    call setline(1, &quot;#include &lt;iostream&gt;&quot;)</span><br><span class="line">    call append(1, &quot;using namespace std;&quot;)</span><br><span class="line">    normal G</span><br><span class="line">    normal o</span><br><span class="line">    normal o</span><br><span class="line">endf</span><br><span class="line">autocmd bufnewfile *.cpp,*.cc call HeaderCpp()</span><br><span class="line"></span><br><span class="line">&quot;C,C++单个文件调试</span><br><span class="line">map &lt;F8&gt; :call Rungdb()&lt;CR&gt;</span><br><span class="line">func! Rungdb()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    exec &quot;!g++ % -g -o %&lt;&quot;</span><br><span class="line">    exec &quot;!gdb ./%&lt;&quot;</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">&quot;====================&quot;</span><br><span class="line">&quot;Vundle Configuration&quot;</span><br><span class="line">&quot;====================&quot;</span><br><span class="line">filetype off                  &quot; required</span><br><span class="line"></span><br><span class="line">&quot; set the runtime path to include Vundle and initialize</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; alternatively, pass a path where Vundle should install plugins</span><br><span class="line">&quot;call vundle#begin(&apos;~/some/path/here&apos;)</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle, required</span><br><span class="line">Plugin &apos;VundleVim/Vundle.vim&apos;</span><br><span class="line"></span><br><span class="line">&quot; My Plugin here:</span><br><span class="line"></span><br><span class="line">&quot; plugin on GitHub repo</span><br><span class="line">Plugin &apos;Valloric/YouCompleteMe&apos;</span><br><span class="line">Plugin &apos;luochen1990/rainbow&apos;</span><br><span class="line">&quot;Plugin &apos;majutsushi/tagbar&apos;</span><br><span class="line">Plugin &apos;fholgado/minibufexpl.vim&apos;</span><br><span class="line">Plugin &apos;scrooloose/nerdtree&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot; All of your Plugins must be added before the following line</span><br><span class="line">call vundle#end()            &quot; required</span><br><span class="line">filetype plugin indent on    &quot; required</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;===========================&quot;</span><br><span class="line">&quot;Vundle Plugin Configuration&quot;</span><br><span class="line">&quot;===========================&quot;</span><br><span class="line"></span><br><span class="line">&quot;Rainbow</span><br><span class="line">let g:rainbow_active = 1 &quot; 0 if you want to enable it later via: RainbowTogglw</span><br><span class="line"></span><br><span class="line">&quot;Tagbar</span><br><span class="line">&quot;nmap &lt;F8&gt; :TagbarToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot;YouCompleteMe</span><br><span class="line">&quot;let g:ycm_path_to_python_interpreter = &apos;/usr/bin/python&apos;</span><br><span class="line">set runtimepath+=~/.vim/bundle/YouCompleteMe</span><br><span class="line">let g:ycm_collect_identifiers_from_tags_files = 1           &quot; 开启 YCM 基于标签引擎</span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释与字符串中的内容也用于补全</span><br><span class="line">let g:syntastic_ignore_files=[&quot;.*\.py$&quot;]</span><br><span class="line">let g:ycm_seed_identifiers_with_syntax = 1                  &quot; 语法关键字补全</span><br><span class="line">let g:ycm_complete_in_comments = 1</span><br><span class="line">let g:ycm_confirm_extra_conf = 0</span><br><span class="line">&quot;let g:ycm_key_list_select_completion = [&apos;&lt;c-n&gt;&apos;, &apos;&lt;Down&gt;&apos;]  &quot; 映射按键, 没有这个会拦截掉tab, 导致其他插件的tab不能用.</span><br><span class="line">&quot;let g:ycm_key_list_previous_completion = [&apos;&lt;c-p&gt;&apos;, &apos;&lt;Up&gt;&apos;]</span><br><span class="line">let g:ycm_complete_in_comments = 1                          &quot; 在注释输入中也能补全</span><br><span class="line">let g:ycm_complete_in_strings = 1                           &quot; 在字符串输入中也能补全</span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot; 注释和字符串中的文字也会被收入补全</span><br><span class="line">let g:ycm_global_ycm_extra_conf=&apos;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&apos;</span><br><span class="line">&quot;let g:ycm_show_diagnostics_ui = 0                           &quot; 禁用语法检查</span><br><span class="line">inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;CR&gt;&quot; |            &quot; 回车即选中当前项</span><br><span class="line">nnoremap &lt;F5&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line">&quot;let g:ycm_min_num_of_chars_for_completion=2                 &quot; 从第2个键入字符就开始罗列匹配项</span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion = 1  &quot; 补全后自动关闭preview</span><br><span class="line"></span><br><span class="line">&quot;minibufexpl</span><br><span class="line">let g:miniBufExplMapWindowNavVim = 1 &quot;可以用&lt;C-h,j,k,l&gt;切换到上下左右的窗口 </span><br><span class="line">let g:miniBufExplMapCTabSwitchBufs = 1 &quot;&lt;C-Tab&gt;,&lt;C-S-Tab&gt;切换</span><br><span class="line">let g:miniBufExplModSelTarget = 1 </span><br><span class="line"></span><br><span class="line">&quot;NERDTree</span><br><span class="line">nnoremap &lt;F4&gt; :NERDTreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title>C++虚函数和Java类比</title>
    <url>/2021/05/31/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8CJava%E7%B1%BB%E6%AF%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小结：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr1pwowrwuj30hk0a8dgv.jpg" alt="image-20210531170324424" style="zoom:50%;"></p>
<ul>
<li>在C++中，多态是靠虚函数实现的，因为如果是普通函数，调用的方法是根据当前指针类型来判断的，而不是根据指针所指向对象的类型，JAVA则是根据实际对象分配的，所以JAVA的普通函数就类似C++的虚函数。</li>
<li>所以C++如果一个类是基类，它的析构函数一定是虚函数。</li>
<li>C++的纯虚函数就类似JAVA的抽象函数，也就是只有函数定义。</li>
<li>C++的抽象类就是JAVA的抽象类，也就是有至少有一个纯虚函数/抽象函数的类。</li>
<li>C++的虚基类就是JAVA的接口，也就是全部是纯虚函数/抽象函数的类。</li>
<li>C++可以多继承，而JAVA只能单继承，所以JAVA又搞了接口出来。</li>
</ul>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/u013630349/article/details/50838558" target="_blank" rel="noopener">C++ 与 Java 之中的虚函数、抽象函数、抽象类、接口 比较</a></p>
<p><a href="https://www.huaweicloud.com/articles/6b9f1996380f9e89335a747ac42322a5.html" target="_blank" rel="noopener">C++虚函数与JAVA中抽象函数比较</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>关于Include</title>
    <url>/2020/01/19/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/%E5%85%B3%E4%BA%8EInclude/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在C/C++中，include本质上就是将代码代入，约定俗成的方法：</p>
<ul>
<li>头文件.h：声明，引用其他文件的时候只需引入头文件，编译器会基于声明在源代码的编译结果中找到定义。如果在头文件中做了定义，可能会出现重复定义的报错，比如A头文件做了定义，B引用A，C既引用B又引用A，则会出现重复定义。</li>
<li>源代码.cpp：编译阶段所有.cpp文件都会被编译，编译器查找声明，在源代码中找到定义。</li>
</ul>
<p>值得注意的是，由于include本质是代码引入，所以其和java的import是不一样的。</p>
<p>举个例子，比如A是一个公共模块，例如日志打印方法(INFO,WARN等)，B引入了A，C既需要引入B，同时也需要日志模块A，在java/python中，同时需要import B和A，而C++只需要import B就相当于引入了A。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C语言中的指针详解</title>
    <url>/2017/06/28/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在创建动态二维数组(数组大小为变量)的时候，遇到了一些关于指针的问题，经过一番试验和研究，将一些比较容易出错的地方进行了归纳整理。</p>
<h1 id="数组名和指针"><a href="#数组名和指针" class="headerlink" title="数组名和指针"></a>数组名和指针</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 4 * sizeof(int)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// sizeof(int*)</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>对于一个数组，数组名从值上来讲就等于它第一个元素的地址，但它和指针其实是有区别的:</p>
<ul>
<li>你可以修改指针的内容，但无法修改数组名的指向。</li>
<li>对于sizeof，数组名得到的是整个数组的大小，指针则是指针类型占的内存大小。</li>
</ul>
<h1 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (* b)[<span class="number">4</span>] = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *c[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// sizeof(int*)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(c) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// sizeof(int*) * 4</span></span><br></pre></td></tr></table></figure>
<p>上述b就是一个数组指针，该指针指向一个长度为4的数组，指针移动1则对应移动4个int。c则是指针数组，b和c千万不要搞混，[]的优先级要高于*, 所以c是一个数组，但该数组储存的都是指针。注意，尽管b是数组指针，但是其占的内存依然是指针类型占的内存大小。</p>
<p>提到数组指针后，就要讲到我的出发点二维数组了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> **a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">4</span>]; <span class="comment">// 错</span></span><br><span class="line"><span class="keyword">int</span>(*a)[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">4</span>]; <span class="comment">// 对</span></span><br></pre></td></tr></table></figure></p>
<p>我刚开始就错写成了第一种形式，发现这样会出错。我的想法是对于int[0]，int[1], int[2]里面储存的是int[4]数组的值，这个值应该就是一位维组名，我等价得以为是指向首个元素的地址，也就是<code>int *</code>类型，那么a就应该是指向指针的指针。</p>
<p>但事实上，正如之前所说，数组名只是在值上等于指向首个元素的地址，但两者并不等价！只是在参数传递，数组名赋值给指针时两者值相等！仔细去想，如果按照我一开始的这种想法，sizeof(*a)就只是一个指针的内存，无法代表一维数组的大小。</p>
<p>因此，int[0]中存储的就只是一维数组名，然后再对该一维数组名取地址，才是正确的指向int[0]的地址，同样的，这个值也是和二维数组名在值上相同，但是并不等价。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> (*a)[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span>(* a)[<span class="number">3</span>][<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>以上才是正确的形式，多维可以类推。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>数组指针， 不能因为数组名在值上等于指针，而等价为指向指针的指针。</li>
<li>指针数组，在值上等价与指向指针的指针，可以将数组名赋给指向指针的指针。</li>
<li>讲真，涉及到多维数组，既然用了c++,那还是用vector吧，简单方便，并且函数传递时是值传递，也可以用引用传递来实现实参改变，比c方便太多了！</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>C++</category>
      </categories>
  </entry>
</search>
